sha,filename,url,lines,title,comment,priority,category,additional,id,private
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/bootstrapper.cc,,450:20-450:45,存储 new Function 创建的函数,-,0,Code Walkthrough,,c981767a-c248-487b-981c-64fd1fa2e2f2,0
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/bootstrapper.cc,,470:16-470:31,initial_map 是构造函数的初始映射,initial_map 是构造函数的初始映射，它定义了当这个函数作为构造函数使用时（通过 new 操作符调用）创建的对象的基本结构和属性。,0,Code Walkthrough,,1baaf95d-80b7-49bf-87d6-bcfa1684b28b,0
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/builtins.h,,176:35-176:44,Builtins::Setup() 中设置的数组,-,0,Code Walkthrough,,2fa9d20b-269d-4d87-b8d2-8045c1ae9d8e,0
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/factory.cc,,53:27-53:39,安全地调用可能触发垃圾回收的堆操作函数,,0,Code Walkthrough,,a1976046-8450-45a2-9184-158f081c2484,0
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/bootstrapper.cc,,487:26-487:61,调用到堆的符号查找机制，确保相同字符串的Symbol只创建一次，实现了Symbol的唯一性,"""""在堆中查找Symbol""""的含义是：在存储于堆内存中的符号表数据结构中查找或创建Symbol对象。这是V8实现Symbol唯一性和高效管理的核心机制。\n\n查找不慢吗?\nV8中的Symbol查找基于哈希表实现，具体在 SymbolTable 类中。",0,Code Walkthrough,,dd807642-364b-4e3a-a9b5-6ba28f4f5bb3,0
aeef99615dea0e7a12c43fa7f392af290b54381c,/src/api.cc,,830:22-830:41,构造时创建的的指针是 ObjectTemplateInfo,构造时创建的的指针是 ObjectTemplateInfo。创建完成后用 ToLocal 转回为 ObjectTemplate,0,Code Walkthrough,,ad13c2ca-35df-49d6-984f-29712d032cc9,0
7a84c50ed1fd12abd3f4072da5224ce299780f11,/public/v8.h,,389:8-389:12,存储当前 HandleScope 的指针,在 HandleScope::Data 类中，next 和 limit 是用于管理句柄块（handle block）中句柄分配的关键指针。 v8.h:389-398\n\nnext 和 limit 的用途\nnext 指针\nnext 指向当前句柄块中下一个可用的句柄位置。 api.cc:362-400 当创建新句柄时，CreateHandle() 函数会：\n\n将 current_.next 的值作为新句柄的存储位置\n在该位置存储句柄值\n将 current_.next 递增指向下一个位置\nlimit 指针\nlimit 指向当前句柄块的末尾边界，用于检测当前块是否已满。 api.cc:364-391 当 result == current_.limit 时，表示当前块已满，需要分配新的扩展块。\n\n工作流程\n句柄分配的完整流程如下：\n\n检查空间: 比较 next 和 limit 判断当前块是否还有空间\n分配扩展块: 如果空间不足，通过 GetSpareOrNewBlock() 获取新块\n更新指针: 设置新的 limit 指向新块的末尾\n分配句柄: 在 next 位置存储句柄值，然后递增 next\n初始化状态\n在 Initialize() 方法中，next 和 limit 都被设置为 NULL，extensions 设置为 -1，表示初始状态下没有可用的句柄块。 v8.h:394-398\n\nNotes\n这种设计实现了高效的线性分配策略，通过简单的指针比较和递增操作来管理句柄分配，避免了复杂的内存管理开销。当句柄块用完时，系统会自动扩展到新的块，确保句柄分配的连续性。,0,Code Walkthrough,,0edace07-55c3-4587-9307-396160093603,0
7a84c50ed1fd12abd3f4072da5224ce299780f11,/public/v8.h,,870:5-870:22,JS 里设置属性描述符,"const obj = {};\n\nObject.defineProperty(obj, """"x"""", {\n  value: 42,\n  writable: false,     // 对应 V8 的 ReadOnly\n  enumerable: false,   // 对应 V8 的 DontEnum\n  configurable: false  // 对应 V8 的 DontDelete\n});\n\nconsole.log(obj.x);   // 42\nobj.x = 100;          // 静默失败（非严格模式），严格模式抛 TypeError\ndelete obj.x;         // false，删除无效\nconsole.log(Object.keys(obj)); // []",0,Code Walkthrough,,9d000a5f-fb01-4193-abd2-79f66a38ae23,0
7a84c50ed1fd12abd3f4072da5224ce299780f11,/src/api.cc,,405:54-405:54,v8::Context 转为 v8::Internal::Context,,0,Code Walkthrough,,ddce0a9f-6540-48c6-a618-1c78c4a6f214,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/api.cc,,2106:0-2107:0,为 global object 补齐 “constructor ” ,这是 V8 给 global object 补齐“constructor <-> instance”对的安全垫，保证它和其他对象一样遵守 FunctionTemplate–ObjectTemplate 的统一机制。,1,Code Walkthrough,,014eb811-6e05-4c37-b0bd-7379ca5b340a,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/log.h,,77:6-77:13,描述VM的四种状态，仅仅是及状态,VMState 实现了一个状态栈机制，用于跟踪 V8 引擎在不同执行阶段的状态：\n\nJS - 执行 JavaScript 代码\nGC - 垃圾收集\nCOMPILER - 编译代码\nOTHER - 其他操作（如 API 调用、拦截器等）,0,Code Walkthrough,,250d1a7c-a093-4f72-be79-c4395ce0b554,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/log.h,,190:25-190:25,采样数据通过 Profiler 线程被写入到日志文件中,采样数,0,Code Walkthrough,,54a3b5cb-f23f-4d25-ac8c-11746a73ec06,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,105:0-105:38,半空间大小，也就是 From 和 To 的大小。2 *  semispace_size_ 是年轻代空间大小,,0,Code Walkthrough,,870affd7-dc29-4a41-b4c6-d4194e515fb8,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2497:2-2498:73,申请双倍的内存，里面找到对齐的地址作为新生代。,内存布局上：OldSpace 放前面（因为对齐要求在 NewSpace，并且 OldSpace 起始大小小，便于腾出对齐地址）。\n容量大小上：OldSpace 最终会比 NewSpace 大很多（几十倍甚至几百倍），因为所有长寿命对象+代码+Map 最终都晋升/常驻在老生代。,0,Code Walkthrough,,f6d9a97b-9f85-4186-98f2-d8a8f25c3c63,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2507:0-2508:0,old_space_start 是申请的地址起始。然后找到对齐的 young_generation_size_ 地址,在 old_space_start 的基础上，找到一个大于等于它的地址，并且保证这个地址是 young_generation_size_ 的整数倍。\n\n,0,Code Walkthrough,,8c089c37-f52c-4bc1-9eba-21a1763df172,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2510:24-2510:63,new_space 过后是  code_space_start，code_space_start + code_space_size,chunk 总大小是 young_generation_size_ * 2。 young_generation_size_ - old_space_size 自然是剩余的 code_space_size,0,Code Walkthrough,,470e035d-3cdf-4b29-9f82-86aea1706ab8,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2513:19-2513:69,initial_semispace_size_ 是起步规模，不用一开始用最大的空间,,0,Code Walkthrough,,6a3c2ee8-98d5-4a3d-a326-c68efda12462,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2519:19-2519:60,old_space_size 是实际起点大小,old_generation_size_ = 老生代允许的最大容量（总配额 / 上限）。\nold_space_size = 初始化阶段从初始 chunk 里切出来的那一块起步空间（实际起点大小）。\n老生代会从 old_space_size 起步，逐步扩展，最多扩到 old_generation_size_。\n,0,Code Walkthrough,,e0d0556a-9dd7-465b-92b3-d56f5aaf7695,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2530:19-2530:27,Map 是对象系统的类型元数据，生命周期长、访问频繁、GC 必须依赖它们，所以 V8 把 Map 单独放到 MapSpace，保证稳定性和效率。,,0,Code Walkthrough,,11c10212-40a0-45c8-92e8-e88fc38d8829,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2536:18-2536:34,典型应用场景：大数组、大字符串、大 TypedArray,,0,Code Walkthrough,,26ef3124-b48a-4208-8687-05b694d08331,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2543:9-2543:25,CreateApiObjects() 只是创建 neander_map_、message_listeners_ 和 debug_event_listeners_ 三个东西。,,0,Code Walkthrough,,af9566d7-58f9-4098-b028-eb7208d7a157,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/bootstrapper.cc,,1093:4-1093:18,合并 ObjectTemplate 创建的对像和传入的 global 对象,,0,Code Walkthrough,,0c9424f1-9ecc-417f-944a-1794121fb731,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/factory.cc,,119:24-119:33,从 Heap 中分配 Struct 所需的空间,,0,Code Walkthrough,,6fe413e8-3e93-4950-9731-73395b647b77,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/heap.cc,,2159:0-2159:11,定义 STRUCT_LIST 的 switch。找到访问 map 的函数，例如 Scirpt 类是 scirpt_map(),,0,Code Walkthrough,,d5ad1933-ca6a-4d77-b120-962d01263817,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/heap.h,,748:2-748:13,定义 STRUCT_LIST 的 Map 实例。提供对象的访问 Map 函数使用,,0,Code Walkthrough,,f8f41e23-b319-4b13-a774-b1365ad78292,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/heap.h,,566:2-566:13,定义 STRUCT_LIST 访问函数。例如 script 是 script_map,,0,Code Walkthrough,,382fa3c8-5192-4346-9fc5-4f4ef79a8fca,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/heap.cc,,1020:2-1020:31,初始化 STRUCT_LIST 声明的 Map。,,0,Code Walkthrough,,87432f1a-8868-4f10-91ea-38fac6de33b8,0

12841db942f1014a9c81a70b9390d683a12eae72,/src/objects.h,,2224:19-2224:32,这里的 kSource/kName是来自它的成员属性定义，刚好 6个,,0,Code Walkthrough,,ac49f846-9c07-4c4d-b39d-6d764c38b85b,0


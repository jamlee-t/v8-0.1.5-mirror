sha,filename,url,lines,title,comment,priority,category,additional,id,private
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/bootstrapper.cc,,450:20-450:45,存储 new Function 创建的函数,-,0,Code Walkthrough,,c981767a-c248-487b-981c-64fd1fa2e2f2,0
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/bootstrapper.cc,,470:16-470:31,initial_map 是构造函数的初始映射,initial_map 是构造函数的初始映射，它定义了当这个函数作为构造函数使用时（通过 new 操作符调用）创建的对象的基本结构和属性。,0,Code Walkthrough,,1baaf95d-80b7-49bf-87d6-bcfa1684b28b,0
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/builtins.h,,176:35-176:44,Builtins::Setup() 中设置的数组,-,0,Code Walkthrough,,2fa9d20b-269d-4d87-b8d2-8045c1ae9d8e,0
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/factory.cc,,53:27-53:39,安全地调用可能触发垃圾回收的堆操作函数,,0,Code Walkthrough,,a1976046-8450-45a2-9184-158f081c2484,0
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/bootstrapper.cc,,487:26-487:61,调用到堆的符号查找机制，确保相同字符串的Symbol只创建一次，实现了Symbol的唯一性,"""""在堆中查找Symbol""""的含义是：在存储于堆内存中的符号表数据结构中查找或创建Symbol对象。这是V8实现Symbol唯一性和高效管理的核心机制。\n\n查找不慢吗?\nV8中的Symbol查找基于哈希表实现，具体在 SymbolTable 类中。",0,Code Walkthrough,,dd807642-364b-4e3a-a9b5-6ba28f4f5bb3,0
aeef99615dea0e7a12c43fa7f392af290b54381c,/src/api.cc,,830:22-830:41,构造时创建的的指针是 ObjectTemplateInfo,构造时创建的的指针是 ObjectTemplateInfo。创建完成后用 ToLocal 转回为 ObjectTemplate,0,Code Walkthrough,,ad13c2ca-35df-49d6-984f-29712d032cc9,0
7a84c50ed1fd12abd3f4072da5224ce299780f11,/public/v8.h,,389:8-389:12,存储当前 HandleScope 的指针,在 HandleScope::Data 类中，next 和 limit 是用于管理句柄块（handle block）中句柄分配的关键指针。 v8.h:389-398\n\nnext 和 limit 的用途\nnext 指针\nnext 指向当前句柄块中下一个可用的句柄位置。 api.cc:362-400 当创建新句柄时，CreateHandle() 函数会：\n\n将 current_.next 的值作为新句柄的存储位置\n在该位置存储句柄值\n将 current_.next 递增指向下一个位置\nlimit 指针\nlimit 指向当前句柄块的末尾边界，用于检测当前块是否已满。 api.cc:364-391 当 result == current_.limit 时，表示当前块已满，需要分配新的扩展块。\n\n工作流程\n句柄分配的完整流程如下：\n\n检查空间: 比较 next 和 limit 判断当前块是否还有空间\n分配扩展块: 如果空间不足，通过 GetSpareOrNewBlock() 获取新块\n更新指针: 设置新的 limit 指向新块的末尾\n分配句柄: 在 next 位置存储句柄值，然后递增 next\n初始化状态\n在 Initialize() 方法中，next 和 limit 都被设置为 NULL，extensions 设置为 -1，表示初始状态下没有可用的句柄块。 v8.h:394-398\n\nNotes\n这种设计实现了高效的线性分配策略，通过简单的指针比较和递增操作来管理句柄分配，避免了复杂的内存管理开销。当句柄块用完时，系统会自动扩展到新的块，确保句柄分配的连续性。,0,Code Walkthrough,,0edace07-55c3-4587-9307-396160093603,0
7a84c50ed1fd12abd3f4072da5224ce299780f11,/public/v8.h,,870:5-870:22,JS 里设置属性描述符,"const obj = {};\n\nObject.defineProperty(obj, """"x"""", {\n  value: 42,\n  writable: false,     // 对应 V8 的 ReadOnly\n  enumerable: false,   // 对应 V8 的 DontEnum\n  configurable: false  // 对应 V8 的 DontDelete\n});\n\nconsole.log(obj.x);   // 42\nobj.x = 100;          // 静默失败（非严格模式），严格模式抛 TypeError\ndelete obj.x;         // false，删除无效\nconsole.log(Object.keys(obj)); // []",0,Code Walkthrough,,9d000a5f-fb01-4193-abd2-79f66a38ae23,0
7a84c50ed1fd12abd3f4072da5224ce299780f11,/src/api.cc,,405:54-405:54,v8::Context 转为 v8::Internal::Context,,0,Code Walkthrough,,ddce0a9f-6540-48c6-a618-1c78c4a6f214,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/api.cc,,2106:0-2107:0,为 global object 补齐 “constructor ” ,这是 V8 给 global object 补齐“constructor <-> instance”对的安全垫，保证它和其他对象一样遵守 FunctionTemplate–ObjectTemplate 的统一机制。,1,Code Walkthrough,,014eb811-6e05-4c37-b0bd-7379ca5b340a,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/log.h,,77:6-77:13,描述VM的四种状态，仅仅是及状态,VMState 实现了一个状态栈机制，用于跟踪 V8 引擎在不同执行阶段的状态：\n\nJS - 执行 JavaScript 代码\nGC - 垃圾收集\nCOMPILER - 编译代码\nOTHER - 其他操作（如 API 调用、拦截器等）,0,Code Walkthrough,,250d1a7c-a093-4f72-be79-c4395ce0b554,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/log.h,,190:25-190:25,采样数据通过 Profiler 线程被写入到日志文件中,采样数,0,Code Walkthrough,,54a3b5cb-f23f-4d25-ac8c-11746a73ec06,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,105:0-105:38,半空间大小，也就是 From 和 To 的大小。2 *  semispace_size_ 是年轻代空间大小,,0,Code Walkthrough,,870affd7-dc29-4a41-b4c6-d4194e515fb8,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2497:2-2498:73,申请双倍的内存，里面找到对齐的地址作为新生代。,内存布局上：OldSpace 放前面（因为对齐要求在 NewSpace，并且 OldSpace 起始大小小，便于腾出对齐地址）。\n容量大小上：OldSpace 最终会比 NewSpace 大很多（几十倍甚至几百倍），因为所有长寿命对象+代码+Map 最终都晋升/常驻在老生代。,0,Code Walkthrough,,f6d9a97b-9f85-4186-98f2-d8a8f25c3c63,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2507:0-2508:0,old_space_start 是申请的地址起始。然后找到对齐的 young_generation_size_ 地址,在 old_space_start 的基础上，找到一个大于等于它的地址，并且保证这个地址是 young_generation_size_ 的整数倍。\n\n,0,Code Walkthrough,,8c089c37-f52c-4bc1-9eba-21a1763df172,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2510:24-2510:63,new_space 过后是  code_space_start，code_space_start + code_space_size,chunk 总大小是 young_generation_size_ * 2。 young_generation_size_ - old_space_size 自然是剩余的 code_space_size,0,Code Walkthrough,,470e035d-3cdf-4b29-9f82-86aea1706ab8,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2513:19-2513:69,initial_semispace_size_ 是起步规模，不用一开始用最大的空间,,0,Code Walkthrough,,6a3c2ee8-98d5-4a3d-a326-c68efda12462,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2519:19-2519:60,old_space_size 是实际起点大小,old_generation_size_ = 老生代允许的最大容量（总配额 / 上限）。\nold_space_size = 初始化阶段从初始 chunk 里切出来的那一块起步空间（实际起点大小）。\n老生代会从 old_space_size 起步，逐步扩展，最多扩到 old_generation_size_。\n,0,Code Walkthrough,,e0d0556a-9dd7-465b-92b3-d56f5aaf7695,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2530:19-2530:27,Map 是对象系统的类型元数据，生命周期长、访问频繁、GC 必须依赖它们，所以 V8 把 Map 单独放到 MapSpace，保证稳定性和效率。,,0,Code Walkthrough,,11c10212-40a0-45c8-92e8-e88fc38d8829,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2536:18-2536:34,典型应用场景：大数组、大字符串、大 TypedArray,,0,Code Walkthrough,,26ef3124-b48a-4208-8687-05b694d08331,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2543:9-2543:25,CreateApiObjects() 只是创建 neander_map_、message_listeners_ 和 debug_event_listeners_ 三个东西。,,0,Code Walkthrough,,af9566d7-58f9-4098-b028-eb7208d7a157,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/bootstrapper.cc,,1093:4-1093:18,合并 ObjectTemplate 创建的对像和传入的 global 对象,,0,Code Walkthrough,,0c9424f1-9ecc-417f-944a-1794121fb731,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/factory.cc,,119:24-119:33,从 Heap 中分配 Struct 所需的空间,,0,Code Walkthrough,,6fe413e8-3e93-4950-9731-73395b647b77,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/heap.cc,,2159:0-2159:11,定义 STRUCT_LIST 的 switch。找到访问 map 的函数，例如 Scirpt 类是 scirpt_map(),,0,Code Walkthrough,,d5ad1933-ca6a-4d77-b120-962d01263817,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/heap.h,,748:2-748:13,定义 STRUCT_LIST 的 Map 实例。提供对象的访问 Map 函数使用,,0,Code Walkthrough,,f8f41e23-b319-4b13-a774-b1365ad78292,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/heap.h,,566:2-566:13,定义 STRUCT_LIST 访问函数。例如 script 是 script_map,,0,Code Walkthrough,,382fa3c8-5192-4346-9fc5-4f4ef79a8fca,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/heap.cc,,1020:2-1020:31,初始化 STRUCT_LIST 声明的 Map。,,0,Code Walkthrough,,87432f1a-8868-4f10-91ea-38fac6de33b8,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/objects.h,,2224:19-2224:32,这里的 kSource/kName是来自它的成员属性定义，刚好 6个,,0,Code Walkthrough,,ac49f846-9c07-4c4d-b39d-6d764c38b85b,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/parser.cc,,737:19-737:26,它是 ParserFactory,,0,Code Walkthrough,,ac4d9473-ac69-49e2-9718-6b4cc8f6c202,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/parser.cc,,541:27-541:35,类成员按照声明顺序调用构造函数。初始化列表的顺序不影响真正调用顺序。,\n类类型成员：如果有默认构造函数且你没指定，编译器会自动调用。\n内置类型成员（int/double/raw 指针…）：不会初始化，值是未定义的。\n顺序：先基类 → 再成员（按声明顺序）。\n初始化列表只是改变默认方式，否则类成员总会构造。\n\n\n\n构造时：Base → MemberA → MemberB → Derived\n析构时：~Derived → ~MemberB → ~MemberA → ~Base\n\n\n,0,Code Walkthrough,,c7fa5282-a46d-4bf2-9f57-ea7ba9012d4f,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/scopes.h,,123:25-123:37,NewTemporary 函数用于创建编译器内部使用的临时变量，主要用于存储中间计算结果和编译器状态,,0,Code Walkthrough,,cc7c1398-857c-417b-baf2-55a637160e26,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/scopes.h,,131:5-131:35,非法重声明的错误表达式确实是在运行时执行到该作用域时才报错，而不是在解析时立即报错。,,0,Code Walkthrough,,b036b7d5-6e16-4dd7-a383-30805f72ca35,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/scopes.h,,173:17-173:25,receiver 在函数作用域里对应 “函数调用时传入的 this 值”。,,0,Code Walkthrough,,6d584dbb-db45-4269-b9cb-5f0ae5ab9315,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/scopes.h,,235:6-235:24,JavaScript 的闭包访问必须高效，所以 V8 在编译期就算好，“往上几层就是我要的变量”，到运行时直接按偏移量取，几乎是 O(1)。,,0,Code Walkthrough,,8feab2b1-ba75-4334-ac2f-dde85a89ca7f,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/scopes.h,,232:7-232:29,这意味着闭包里访问自由变量时，不需要多级查找，可以直接定位到全局。,,0,Code Walkthrough,,f857cfe8-35f1-4fba-8b9b-75744cd4cfa3,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/scopes.cc,,163:36-163:61,定义 this 变量，脚本本身也有这个变量,,0,Code Walkthrough,,d313ef30-dd9a-46ac-b327-43371703fc37,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,215:22-215:35,先增加未解析的变量，后解析。支持同名，每个Unresolved 的是一个变量代理位置。,,0,Code Walkthrough,,ba38e3b8-bd4d-48fd-b728-0c396fd8732f,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,225:12-225:28,unresolved_ 中移除 proxy,意味着这个代理 Proxy 已经找到目标 Variable，可以退役了，不再算“悬而未决”的引用。,0,Code Walkthrough,,2a7a469c-81c5-4a97-8694-3d18b74eacb0,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,95:2-95:42,Proxy.scope_ = NULL 只表示“这个 Proxy 没有静态 owner，需要 runtime lookup”。,- Proxy 的 scope_ == NULL ≠ 我不知道父级是谁\n- 它只是编译时不能静态绑定变量\n- 建立 Context chain 的“上级是谁”靠的不是 Proxy.scope_，而是 Scope 对象本身的 parent 指针 (outer_scope_)，以及运行时调用点的 ExecutionContext\n\n换句话说：\n- Context 链是 scope 结构树决定的（词法作用域 + eval 调用点），不是某个 Proxy 的字段决定的。\n- Proxy.scope_ = NULL 只表示“这个 Proxy 没有静态 owner，需要 runtime lookup”。,0,Code Walkthrough,,6f91943e-cc49-4cda-9d6f-04f71bbb3924,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,246:12-246:26,Scope 之所以要保存声明 (Declaration)，是为了在解析和符号绑定过程中记录这一段代码里“显式声明了哪些名字”。,Scope 之所以要保存声明 (Declaration)，是为了在解析和符号绑定过程中记录这一段代码里“显式声明了哪些名字”。\n这是构建符号表（Variable 列表）的第一步，之后才能正确地进行变量解析、闭包捕获、上下文分配。\n,0,Code Walkthrough,,05428f73-0eb3-40d5-ac72-53c31b52b4e0,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,251:12-251:35,记录“第一次发现非法重声明”的出处（AST 节点）,保存非法声明的 AST 节点，方便后续 Visitor 抛出 SyntaxError 并指明具体错误位置。记录下来，再统一处理：这样 Scope 只负责“发现”，Visitor 负责“报错”，分工明确，错误定位信息完整。\n,0,Code Walkthrough,,c6e9572e-86da-45db-91a3-909752c0dce0,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,225:23-225:33,"比如遍历 Block, node->Accept --> Visit --> VisitBlock",,0,Code Walkthrough,,59e3e9dc-e747-49ee-8ffc-b4499cb3861e,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,1208:15-1208:30,Visitor 调用 VisitStatements 访问内容。也就是说 Statements 支持这个 Vistor 访问它,,0,Code Walkthrough,,bfa7b32a-36b5-40a3-a729-06b623145c8b,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.cc,,49:4-49:25,语法节点调用Accept，然后调用例如 v->VisitExpressionStatement ,,0,Code Walkthrough,,3cfdcb2f-caea-4a4f-91d9-71e211cac2b0,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,263:2-263:35,illegal_redecl 虽然是 Expression 抽象类，它可以调用虚函数 Accept。转发调用到底层子类,,0,Code Walkthrough,,dd2815f0-7a57-4b6e-931c-f7d5924df09b,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.cc,,166:4-166:29,Visitor 子语句,,0,Code Walkthrough,,4944ca00-59e8-4a83-9772-48ace18fc489,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,268:12-268:32,Scope 里面的临时变量和本地变量收集到参数 locals 中,,0,Code Walkthrough,,3e0ae72b-93a3-46ea-8a36-19c5f498b457,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,288:0-292:50,语法：显式实例化模板。C++98 标准就已经规定了,强迫编译器“马上生成指定类型的模板函数版本”，而不是等到别的地方用到时再生成。这样可以保证函数的定义在链接阶段一定存在。,0,Code Walkthrough,,3ce9b159-f4c1-4a55-b8e6-2e8bea9aeb3e,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,296:0-296:31,说明这个函数只会在 最外层调用：全局作用域或 eval 作用域。,,0,Code Walkthrough,,ddd3ef29-ec9c-4692-944d-eaaba4757d35,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,642:4-642:35,外部 scope 调用了 eval,,0,Code Walkthrough,,8097fab1-d663-4a5a-9622-fffaef5f6d05,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,649:6-649:29,内部 scope 调用了 eval,,0,Code Walkthrough,,6bb6b00b-ba0a-4331-a0dc-7430a78dbc64,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,304:2-304:20,标记整个 scope 树的 eval 传递,“如果链里的任何函数调用了 eval，整个链（从树根到这个枝叶）不就都要用 Context 了”\n是的，就是这样！\n这就是为什么引擎看到 eval，就要尽量保守，把整个 scope 链的变量都放 Context，这样 运行时 scope chain 查找 eval 里提到的名字，一定能成功。,0,Code Walkthrough,,1dfa486d-bdfe-44e4-be74-d9eb6da7094a,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,602:8-602:38,变量解析保持动态决议,,0,Code Walkthrough,,8e5f4584-6b52-44f4-b4d1-567f1d39a755,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,577:6-577:26,变量在 With 语句中,,0,Code Walkthrough,,ff84a963-1069-482a-88ee-6c14ec8a2508,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,307:2-307:29,global_scope = NULL 表示 “这里我不静态兜底到 global，保留动态决议”。,,0,Code Walkthrough,,806c6942-2fed-431d-949b-6a61dd543460,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,316:12-316:24,当前 scope 或者子 scope 调用了 eval,,0,Code Walkthrough,,f42f6089-6217-48dd-8804-7ad5008b8e39,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,508:17-508:32,从当前 scope 向父作用域递归查找name的变量定义,是的，这个函数本质就是 从当前 scope 向父作用域递归查找变量定义：\n\n本作用域里有没有 → 有就返回。\n没有 → 看是不是函数自名 → 否 → 去 outer_scope。\n如果沿途遇到 eval/with 干的 scope → 就只能返回 NULL，让 runtime 查。\n如果 inner scope 在查 → 顺便打 closure 捕获标记。,0,Code Walkthrough,,f5ed6347-fe91-4f71-910d-e2506eadd794,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,575:34-575:47,解析变量指已知当前 scope 的 proxy->name()，找到父级的Scope 中 locals 的定义变量,,0,Code Walkthrough,,23ee665b-d99b-4b96-8802-a8bfca05f5bb,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,625:12-625:39,解析当前 scope 的  proxy，找到指向的变量,,0,Code Walkthrough,,c7e70b63-2084-476a-8e03-152d1cecdda8,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.h,,270:0-271:0,当前作用域解析不了的变量，要找父级 scope。或者运行时动态解析,,0,Code Walkthrough,,63d5a066-e4c7-4b85-b3ec-aa5793fc79c0,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,630:11-630:11,解析当前 scope 未解析的变量,,0,Code Walkthrough,,f30a1582-9ff7-4872-9b77-5e0dc54e640f,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,535:8-535:17,function_ 就是“函数自己”的名字（function literal 的名字）。,,0,Code Walkthrough,,b475524e-1b35-47ed-a0ca-8fce41a9950f,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,309:2-309:29,unresolved_ 数组中的 proxy 绑定父级scope里的变量,,0,Code Walkthrough,,7b85d597-ec1f-4d91-8091-a0383730f092,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,312:2-312:30,var->rewrite_ 分配上 Slot,,0,Code Walkthrough,,6527ef15-76d8-435a-ab3e-397dc714188c,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,660:12-660:24,变量是否必须分配,Scope::MustAllocate(var) 的意义：\n\n检查一个变量是否必须在运行时拥有真实存储槽位（stack slot / context slot / global property），否则就可以优化掉。\n以下情况必须分配：\n被闭包捕获\neval 存在\nwith 存在\n是全局变量\n关键字 this\n一句话：\n👉 凡是 JS 语义上无法在编译期“完全静态确定”的变量，都必须在 MustAllocate 里被标记为 used，从而分配到 Context/Heap 或 Global。\n\n,0,Code Walkthrough,,c045b3ad-f09c-486a-acf3-29d32fc3d7ec,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,674:12-674:33,进一步判别它是不是必须放进 Context 对象 (heap)，而不是简单的 Stack slot (栈空间),,0,Code Walkthrough,,57449e15-b9e6-4ea9-a264-cb8ac79deba0,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,326:12-326:29, trivial context = 说明 scope 不需要真实的堆上的 context 对象，访问变量靠 stack/global 就够了。,沿着当前 scope → 外层 scope链 一直向上看：\n如果遇到 eval scope → 非 trivial\n如果遇到 with scope → 非 trivial\n如果该作用域本身有 heap slots（即 Context 变量） → 非 trivial\n如果以上都没有 → trivial。,0,Code Walkthrough,,3e761b6f-e8b5-4209-8c9b-e6e48f44c6dd,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,321:12-321:33,外部有 eval ⇒ 内层函数不能 lazy compile，,你之前问到的 AllowsLazyCompilation 的设计点就是：\n\n如果 outer 有 eval → inner 不允许 lazy compile，必须 eager compile。\n原因：\n懒编译意味着 inner 在第一次调用时才做完整解析 → 但那个时候，outer 已经可能执行过部分代码（包括 eval 插入过名字），这会导致 inner 的变量解析逻辑和 outer 的环境在时间上不同步 💥。\neager compile 的好处：在 outer 创建 inner 的那一刻，inner 就绑定好“outer 的 Context 环境引用”，保证后续运行时 eval 才能注入并被 runtime lookup 看见。,0,Code Walkthrough,,a3bc338f-c7ce-43aa-8309-06266ae2a07a,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,350:11-350:29,计算父级 Scope，只有 Scope 有 num_heap_slots 才计数为链长度,,0,Code Walkthrough,,44fc93b6-c5ff-4034-a117-d10c9ef87f23,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,340:12-340:34,outer_scope 是否全部都是 trivial context,,0,Code Walkthrough,,468e1b41-142e-4603-89e7-681249046eba,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,479:17-479:25,nonlocals_ = 作用域内“编译期不能静态绑定的标识符引用”集合,nonlocals_ = 作用域内“编译期不能静态绑定的标识符引用”集合。\n来自三大场景：\nwith → 属性遮蔽，无法确定绑定\neval → 动态插入/修改名字\n未解析（全局） → 留给 runtime global lookup\n编译器在生成代码时，对这些变量一律走 runtime lookup，而不是绑定静态 slot。,0,Code Walkthrough,,211018d3-64ff-4c00-85a9-687d90ac565d,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,689:12-689:33,"检查当前函数作用域的形参列表里有没有名字叫 """"arguments"""" 的参数。","Scope::HasArgumentsParameter() 的作用就是 ——\n\n检查当前函数作用域的形参列表里有没有名字叫 """"arguments"""" 的参数。\n如果有 → arguments 在这个函数体里只是一个普通变量，不再自动创建默认的魔法 arguments 对象。\n如果没有 → 按规范",0,Code Walkthrough,,f8566dff-6c75-4b30-955a-d2b06dc40d8d,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,698:12-698:29,给变量分配在函数栈帧的局部槽，最快。,,0,Code Walkthrough,,1733ac27-100f-45e4-98fe-9d3323b040b1,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,703:12-703:28,给变量分配在堆上的 Context 对象，能跨函数作用域共享，但访问慢。,,0,Code Walkthrough,,52aef575-2e10-4f6a-96ec-cb90d447a6c7,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,772:8-775:36,把形参 var 的访问点，改写成访问隐藏变量 .arguments 的第 i 个属性。这样以后所有读写参数其实都翻译成对 .arguments[i] 的读写，从而保证 arguments 对象和形参变量始终保持一致。,,0,Code Walkthrough,,0b17cbdb-c8cf-413c-933e-8a92b8edd162,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,174:4-174:13,this 指向 var,,0,Code Walkthrough,,ca6fceba-042a-40fe-af43-fba33935bb2a,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,181:4-181:11,在 locals_ 声明 arguments 特殊变量，,,0,Code Walkthrough,,25c7fc82-3f9a-499b-9fad-ea73a8b96e52,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,192:17-192:35,函数在它的 函数体内部要能引用自己的名字。,,0,Code Walkthrough,,c98c9372-cf7d-486a-bcca-74a59003f3db,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,208:12-208:24,函数 Scope 添加参数。locals_ 有这个 var，然后也加到 params_,,0,Code Walkthrough,,a15ffae5-2863-4859-ad1b-e08dcd80bfcc,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,237:22-237:34,temps_ 增加临时变量,,0,Code Walkthrough,,e5b81e8a-565c-4fda-8a4f-ed284fa404c9,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,39:35-39:35,Allocator 默认调用 free 和 malloc 。这里重写调用 Zone::New,,0,Code Walkthrough,,f08abe45-dc1f-4daf-be1e-6392bff52d7a,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/zone.h,,54:14-54:23,一次释放所有申请的内存,,0,Code Walkthrough,,39507e6c-786a-4d5b-a489-e5768c0414dc,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/zone.cc,,63:0-64:0,Segment 不光包含两个头信息字段，它剩下的“身体”就是用户请求的那一大快内存区。,,0,Code Walkthrough,,c8a93dce-1525-4c2d-9d77-3d739d0ba038,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,41:7-41:17,编译器为了更合理评估热度，调用时可能给权重,,0,Code Walkthrough,,b0edcb4c-5851-4f3e-b870-faa2521fb5d8,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,134:14-134:22,把源代码里写的“名字引用”节点 (VariableProxy) 替换成更精确、更低层的节点（Slot 或 Property）。,,0,Code Walkthrough,,74904752-bff5-4ebd-88bb-84865b860ccb,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,118:2-119:20,只有作用域管理器 (Scope) 和 VariableProxy 等“受信任的类” 才能 new Variable,friend 类才可以创建变量,0,Code Walkthrough,,8dbdae4d-f6ad-401c-95da-c805f613eb8f,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,129:11-129:20,表示 变量本身的值 被读/写的次数。,,0,Code Walkthrough,,9e5f97c0-7fd8-4e03-b66e-fa3b2c4ac569,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,130:11-130:20,表示 变量作为“对象/函数本身” 被当作目标使用的次数。,function f() {}\nvar g = f;\n\ng();         // 调用 → obj_uses_++\ng.x = 42;    // 当对象添加属性 → obj_uses_++,0,Code Walkthrough,,78439bb6-1d79-45fa-984f-d01333ca77a2,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/hashmap.h,,44:6-44:13,直接沿用最底层的 Malloced 内存管理，默认也就是 free 和 malloc。,,0,Code Walkthrough,,794a0f77-48aa-4915-89d7-fdcdead4b8ec,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,845:6-845:14,Property 表示对象属性访问,"FunctionLiteral(""""foo"""")\n│\n├── params_: [ """"x"""" ]\n│\n└── body:\n    ├── VariableDeclaration                 // var y = 1;\n    │      ├── VariableProxy(""""y"""")           // 声明的名字\n    │      └── Literal(1)                   // 初始化表达式\n    │\n    └── ReturnStatement                     // return ...\n           └── BinaryOperation(""""+"""")\n                 ├── BinaryOperation(""""+"""")\n                 │     ├── BinaryOperation(""""+"""")\n                 │     │      ├── VariableProxy(""""x"""")       // 使用参数 x\n                 │     │      └── VariableProxy(""""y"""")       // 使用局部 y\n                 │     │\n                 │     └── Property                        // obj[""""a""""]\n                 │            ├── VariableProxy(""""obj"""")     // 对象部分\n                 │            └── Literal(""""a"""")             // key 部分\n                 │\n                 └── Property                              // obj.b\n                        ├── VariableProxy(""""obj"""")\n                        └── Literal(""""b"""")",0,Code Walkthrough,,4895f2b5-3814-48f5-b718-6ed9d3fb522a,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,730:6-730:19,变量引用或者声明时的引用,"FunctionLiteral(""""foo"""")\n  ├── params_: [""""x""""]   // 形参\n  └── body:\n      ├── VariableDeclaration\n      │     ├── VariableProxy(""""y"""")   // 声明处的名字\n      │     └── Literal(1)           // 初始化\n      │\n      └── ReturnStatement\n            └── BinaryOperation(""""+"""")\n                  ├── BinaryOperation(""""+"""")\n                  │     ├── VariableProxy(""""x"""")   // return 里的 x\n                  │     └── VariableProxy(""""y"""")   // return 里的 y\n                  │\n                  └── VariableProxy(""""z"""")         // return 里的 z",0,Code Walkthrough,,09aeeafd-198b-47e7-be0f-eae4c71b29b9,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,770:11-770:20,UseCount 会在 BindTo 之后汇总到真正的 Variable 上，用于后续代码生成/优化的启发式判断,,0,Code Walkthrough,,a5c80489-8efc-4712-a804-449638d0048c,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,741:11-741:23,“this 怎么可能是 NULL”——按标准不应该；只有你通过空指针调用成员函数时才“可能”为 NULL，但那是未定义行为。这段代码是历史上的防御式写法，实务中常见但不推荐在新代码里照搬。,,0,Code Walkthrough,,c1a6cdce-9735-4edf-b85b-66e0755b8388,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,89:7-89:26,"能不能作为赋值或自增自减的“左边”（Left-Hand Side, LHS）。",,0,Code Walkthrough,,aef44fc4-a742-4264-9bd9-c4fc2059588b,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,87:0-88:0,当使用 arguments 对象时，参数会被重写为 Property ,,0,Code Walkthrough,,e194db41-5ab7-467f-83ac-6cb671037fff,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.cc,,105:35-105:43,Expression 转为 Property。底层本身就是 Property,,0,Code Walkthrough,,af631b9d-e032-4832-907a-79d4b7c82596,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,806:10-806:60,参数变量重写为 Slot,,0,Code Walkthrough,,4bb3909f-961d-4f65-bc36-c0b5a422cc85,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,171:6-171:24,因为 JS 语法允许 labeled block 被 break label; 跳出，它必须具备“break 目标”的特征。,,0,Code Walkthrough,,6915828e-f480-4056-ba40-e2953722e6d9,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,206:6-206:25, “breakStackHeight” 确实对应 操作数栈高度,在 V8 0.1.5 这种上古版本（2008 年刚开源那会儿），确实还是 stack‑based 的 JVM 风格模型。\n当时根本 还没有今天所说的 IR pipeline（Hydrogen/Lithium/Turbofan/Ignition bytecode），而是直接从 AST 一路吐汇编（Full-codegen）。,0,Code Walkthrough,,f50a90d2-1e88-4f4a-bb69-c863064ead73,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,248:2-248:15,声明里面是 VariableProxy，Scope 用到它,,0,Code Walkthrough,,ddccd39c-58b8-476c-80b2-39861bcc1b98,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,278:6-278:19,组合子的节点，实现 AST 的父子级的关系；另外它也继承基类实现逻辑共享,,0,Code Walkthrough,,5976a719-0833-43f0-9ede-2038099f9362,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,230:6-230:17,变量声明、函数声明、 常量声明,"特殊做法：函数表达式\n\nvar x = function hello() { return 1; };\n\nVarDeclaration\n ├─ Declaration\n │    ├─ proxy_: VariableProxy(""""x"""")   // 声明的名字是 x\n │    ├─ mode_: VAR\n │    └─ fun_: NULL                   // 注意！这里 fun_ 是 NULL\n └─ Initializer\n      └─ Assignment (=)\n           ├─ VariableProxy(""""x"""")\n           └─ FunctionLiteral(""""hello"""")   // FunctionExpression 节点\n                ├─ name: """"hello"""" (可选局部名)\n                └─ body: [ ReturnStatement Literal(1) ]\n",0,Code Walkthrough,,ec766282-9c83-4a2d-920b-bba34eada438,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,250:19-250:23,只有函数声明用到,"function foo(a, b) {\n  return a + b;\n}",0,Code Walkthrough,,4e8a9dda-d7a9-4633-bc3b-a214fb9fb40d,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,1116:6-1116:21,重要：语法层的函数定义表达式/声明,"语法层的函数定义表达式/声明\n\n\n\nfunction foo(a, b) {\n  return a + b;\n}\nvar bar = function(x) { return x * 2; };\n在 AST 上都会生成一个 FunctionLiteral 节点。\n\n包含信息：\n\nname_: 函数名字（匿名函数时可能是空字符串）。\nscope_: 函数作用域对象（捕获变量、参数、this 绑定）。\nbody_: 语句列表（函数体 AST）。\nmaterialized_literal_count_: 函数体里需要 materialize 的字面量数量。\nexpected_property_count_: 预期构造对象字面量的属性数量（优化 hint）。\nnum_parameters_: 参数个数。\nstart_position_, end_position_: 源码位置。\nis_expression_: 是“函数表达式”还是“函数声明”。\n👉 它就是“一个 JS 函数的源码 AST 节点”。",0,Code Walkthrough,,cec899f8-2be3-47c2-8b83-6e4e0a1ff532,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,424:6-424:16,switch 语句里每个 case/default 分支的 AST 节点,,0,Code Walkthrough,,b3c65617-5594-400b-8d99-96f8a82eb831,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,489:2-490:29,每种 Node/Statement 子类都有各自的 AsXXX() 转换或 type-tag。这样编译/代码生成时可以动态区分实际类型,Statement* s = if_stmt->then_statement_;\nif (s->AsBlock() != NULL) {\n   // then 分支是个块\n} else if (s->AsReturnStatement() != NULL) {\n   // then 分支是 return\n} else if (s->AsExpressionStatement() != NULL) {\n   // then 分支是表达式语句\n},0,Code Walkthrough,,98201a2c-e74d-489e-b25e-1f1c900652ae,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,496:6-496:20,临时收集和保存 Label* 列表，供带 label 的 break/continue 做静态绑定,举个伪例：源码 → LabelCollector 使用\nJavaScript\n\nfoo: { \n  bar: while (true) {\n    break foo;\n  }\n}\nparser 遇到 foo:，暂时没有真正的语句 target → 放进 LabelCollector。\n遇到 {…} → 创建 Block → 将 foo 绑定到 Block。\nBlock 继承自 BreakableStatement，可以接收 break label。\n遇到 bar: + while → 将 bar 绑定到 WhileLoop。\n遇到 break foo; → 通过 label 查找到 Block 的 break_target。 Done ✅,0,Code Walkthrough,,03789b3a-0d52-47fe-835c-a16e75ce76cf,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,578:6-578:23,js 语法：`debugger;`   // 在这里停下来（如果有调试器）,,0,Code Walkthrough,,ca614f79-a7d2-4e1c-9609-7777b4ad30a8,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,593:6-593:13,V8 AST 里最“基础”的 表达式节点 (Expression) 之一——它用来表示 字面量 (literal),"null\ntrue\nfalse\n42\n3.14\n""""hello""""\n\n/abc/      // RegExp literal\n[]         // Array literal\n{}         // Object literal\n\n\n示例 A：简单字面量\nJavaScript\n\nvar a = 42;\nAST（简化）：\n\n\n\nVarDeclaration\n └─ init: Literal(42)\n这里 Literal(42) 存放在 handle_ 里，指向 V8 Heap 中的 Smi 对象 42。",0,Code Walkthrough,,6118b183-4e1f-49f8-83da-9aab5fa78480,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,622:6-622:25,MaterializedLiteral ——它和前面简单的 Literal 不一样。这个类是 V8 早期 AST 用来表示那些 “需要在运行时真正分配对象”的字面量” 的基类,,0,Code Walkthrough,,9cf6e1c7-cd07-4dcf-a942-96dda51065a2,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,683:11-683:19,对象属性,,0,Code Walkthrough,,e8112d68-33aa-4243-a692-866d19e852b3,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,875:6-875:10,Call（普通调用）,,0,Code Walkthrough,,2795f7f8-c1ce-4d46-9739-b279a943e0c1,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,908:6-908:13,CallNew（构造调用）,,0,Code Walkthrough,,877316c6-06da-4714-834d-4a2e43cc4af3,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,921:6-921:17,源码里的“高级语法” → AST 初步节点 → Rewriter → CallRuntime → Runtime Helper,是的，CallRuntime 恰恰就是 V8 在 AST 转换 (Rewriter) 中引入的特殊节点。\n它不是语法，而是编译器“降级成 runtime helper 调用”的占位。\n常见被 rewrite 成 CallRuntime 的：\n对象字面量初始化\nRegExp 字面量\neval 特殊调用\n内置库方法的优化路径\n,0,Code Walkthrough,,00b09697-cbee-423e-bdca-276f94fcb2ee,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,941:6-941:20,对应 JS 源码里的 一元运算符表达式。比如：-x、!x、typeof x、delete obj.prop 这些，都会被建模成 UnaryOperation 节点。,,0,Code Walkthrough,,045b2f52-9a83-4689-b1a4-da5dee514eb4,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,1011:6-1011:20,"专门表示前缀/后缀自增自减：++x, x++。因为这类不仅是值，还涉及赋值，会比简单一元复杂。",,0,Code Walkthrough,,7b60775a-c882-490d-85d7-18f7a4a5ada3,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,1189:6-1189:18,只是引擎内部当你写到**“函数自身的引用”**（callee 或解析命名函数表达式时）会生成。,,0,Code Walkthrough,,6173e396-3129-426a-8ef0-62e88ac76b66,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,1173:6-1173:32,如果某个地方需要“在执行时生成或克隆一个 Function 对象”，AST 节点就放一个 FunctionBoilerplateLiteral 来指代那个“模板函数对象”。,看到源码 function foo() {} → 是 FunctionLiteral；\n看到对象/数组字面量里含函数属性 → AST 会存一个 FunctionBoilerplateLiteral，跑时 clone 模具。,0,Code Walkthrough,,e2b0df44-1eb3-4007-a6d7-e9589794351c,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/parser.cc,,526:6-526:23,Parser: 语法解析器类,,0,Code Walkthrough,,83fd3f35-d381-4785-bd4e-150fdf1283dc,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/parser.cc,,737:39-737:49,parser 的默认 top_scope_ 是 NULL,,0,Code Walkthrough,,905bfbed-acff-4e8c-82b8-2eeb8c90574c,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/compiler.cc,,210:19-210:23,is_global 是 true,,0,Code Walkthrough,,e97a390f-f4dc-44b5-8d0b-8ea0d5590148,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/parser.cc,,634:6-634:18,LexicalScope 就是个小 RAII 工具，保证进入/退出作用域时，parser 的 top_scope 状态成对切换，不会忘记恢复。,,0,Code Walkthrough,,ed04abfa-cead-4b62-b87d-b03b2fbc6157,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/parser.cc,,853:4-853:55,成功解析一条语句，添加到 processor，它负责收集,,0,Code Walkthrough,,9ed1711f-1a18-4a65-ab94-4897b6bd43f4,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/compiler.cc,,159:15-159:37,函数变为模板，克隆它生成新的函数对象。,,0,Code Walkthrough,,a170297a-f664-4151-ba61-ee0db345185c,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/parser.cc,,2889:12-2889:45,函数表达式关联到了它对应的 Scope，1个函数只有1个哦,,0,Code Walkthrough,,99628cc6-691f-488d-af1f-0acc1744d0c2,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/prettyprinter.cc,,984:4-984:26,打印的时候检查 rewrite ，所以打印优化过的,,0,Code Walkthrough,,cd7b30ea-9918-4707-b515-0a0a1175ee2f,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/codegen-ia32.cc,,3419:2-3419:34,也会检查 rewrite,,0,Code Walkthrough,,0e9b41cb-698f-4304-b1ae-c8cebdb8467d,0
083bcda64f5dcbdd486c27bc6a3e6dfd8213677f,/src/codegen-ia32.cc,,361:2-361:63,MakeCode 是静态函数,,0,Code Walkthrough,,420d09a9-14bf-4b19-8472-76f7f208f545,0
083bcda64f5dcbdd486c27bc6a3e6dfd8213677f,/src/assembler-ia32.cc,,384:2-384:16,生成的命令都是通过 pc 来写入的,,0,Code Walkthrough,,aac40600-c3d7-467a-aaf5-5f11776154ee,0
083bcda64f5dcbdd486c27bc6a3e6dfd8213677f,/src/codegen-ia32.cc,,409:6-409:51,初始化 masm ,,0,Code Walkthrough,,cf8693c5-72d9-4fc1-91b3-cc0e9fbb61c7,0
9604e629901f2248e2812510252653985b87dfdc,/src/assembler-ia32.h,,66:6-66:10,寄存器要转为操作码，因此用类更方便,,0,Code Walkthrough,,89912ad6-0675-416c-8722-3c5c0e20ecc9,0
9604e629901f2248e2812510252653985b87dfdc,/src/assembler-ia32.cc,,52:9-52:12,在 opcode 中，eax的编码是0,eax的编码是0\necx的编码是1\nedx的编码是2\nebx的编码是3\nesp的编码是4\nebp的编码是5\nesi的编码是6\nedi的编码是7,0,Code Walkthrough,,892ddb4e-e82f-4ecb-9ce3-35fc33d07525,0
9604e629901f2248e2812510252653985b87dfdc,/src/api.cc,,1076:2-1076:40,初始化 TryCatch 时注册 TryCatchHandler,,0,Code Walkthrough,,2b082c98-c571-415b-9824-ce43a0c5cb51,0
9604e629901f2248e2812510252653985b87dfdc,/src/execution.h,,234:6-234:29,一段作用域内，暂时“推迟（postpone）处理 interrupts/中断事件”，等离开作用域的时候再统一启用和处理。,,0,Code Walkthrough,,449fb941-90d1-4c9c-a88c-add136a095fe,0
9604e629901f2248e2812510252653985b87dfdc,/src/execution.cc,,86:4-87:55,这里的 code 就是由 JSEntryStub/JSConstructEntryStub 动态生成的机器码入口对象，调用 code->entry() 后相当于跳进那段汇编桥接代码去执行 JS。,,0,Code Walkthrough,,06170377-5ae9-46e0-b389-1fc4c4b0121c,0
9604e629901f2248e2812510252653985b87dfdc,/src/code-stubs.cc,,61:10-61:10,CodeStub 子类会实现 Generate 方法生成 Stub ,,0,Code Walkthrough,,b73e90bd-3e65-40fe-943a-bda4c04a9010,0
9604e629901f2248e2812510252653985b87dfdc,/src/code-stubs.h,,74:0-75:0,子类实现这个纯虚函数生成 Stub,,0,Code Walkthrough,,2de0a895-2b58-4435-b304-ccd0751d1058,0
9604e629901f2248e2812510252653985b87dfdc,/src/ic.h,,52:6-52:8,IC 是一种“在执行点安装快速路径”的动态优化技术。,"在当年的体系里，大体就是围绕 属性读、属性写、函数调用 三大类。比如（老版本的内心世界）：\n\nLoadIC\n负责 obj.prop 属性读取。\n初次访问走 runtime，发现对象 layout（Map）和属性偏移，patch fast path。\nStoreIC\n负责 obj.prop = ... 属性写入。\nPatch 成为直接偏移写，避免字典查找。\nCallIC\n负责函数调用 obj.method()。\n可以直接缓存 target stub，避免每次查找函数。\nKeyedLoadIC / KeyedStoreIC\n负责 obj[""""""""dynamicProp""""""""] 的访问 / 存储（即带 key 的情况）。\n处理数组下标存取（arr[i]）。\n后来随着功能完善，还补充了各种更细的（ConstructIC、CompareIC、UnaryOpIC 等），但是在 0.1.5 时期，重点就是对象属性和方法调用这几个。",0,Code Walkthrough,,07e7d042-a44f-410a-b89b-2b65efb4fdec,0
9604e629901f2248e2812510252653985b87dfdc,/src/frames.h,,110:6-110:16,StackFrame 类及其子类（如 JavaScriptFrame、EntryFrame）不是创建栈帧，而是解释已存在的栈帧结构,,0,Code Walkthrough,,64d78284-58c9-4e39-a206-80eaf7475414,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2230:2-2230:54,"这段实际上就在“手写一个布局表”, 所以最终一个 Script 堆对象的大小就是 kSize。",这段实际上就在“手写一个布局表”：\n\nheader（每个堆对象都有）：HeapObject::kSize\nsource：1 个指针值\nname：1 个指针值\nline_offset：1 个 tagged Smi（指针大小 slot）\ncolumn_offset：1 个 tagged Smi\nwrapper：1 个指针值\ntype：1 个 tagged Smi\n总大小 = kSize\n所以最终一个 Script 堆对象的大小就是 kSize。,0,Code Walkthrough,,4616c7a0-5015-4e4b-9746-05077cf37ae6,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,934:2-940:36,properties 字段、elements 字段,"properties 字段：默认是 FixedArray（Map.descriptors 决定 slot 含义），但属性过多/动态时会变成字典。\nelements 字段：可以是 FixedArray（fast array）或 NumberDictionary（稀疏/slow array）；所以源码把它写成更通用的 HeapObject。\n\n\n其实 FixedArray 并不存属性名，它只是个定长“值数组”。\n属性名 → slot 索引 的对应关系在 Map 的描述符表 (DescriptorArray) 里。\n\n流程是：\n\n对象有个 map 指针 → 指向 Map。\nMap 里有个 descriptors 指针 → 指向 DescriptorArray。\nDescriptorArray 里记录 (name, attributes, field_index)。\nfield_index 就是属性 foo 在 FixedArray 里的索引。\n访问 o.foo：\n查 Map 的 descriptors，找到 """"foo"""" 对应的 field_index = 比如 2。\n在 properties 这个 FixedArray[2] 里取出值。\n",0,Code Walkthrough,,9db80370-d165-4f57-86e4-1e7795b69cdf,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2469:2-2469:59,从父类的 JSOBbject::kHeaderSize 算起，加两个属性的指针大小,,0,Code Walkthrough,,9afae163-7672-44ce-ac8f-127882b7b9c4,0
9604e629901f2248e2812510252653985b87dfdc,/src/heap.h,,742:0-744:23,比如定义静态成员：boilerplate_function_map_ ，Map 对象,,0,Code Walkthrough,,b9fbd58b-7b2c-42c2-9e17-d6454a2fa4c0,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2369:6-2369:16,JSFunction 在不同的Map下 kPrototypeOrInitialMapOffset 解释是不同的：样板函数、普通函数、构造函数,\n| 使用的 Map                  | 槽位里存什么                         | 语义解释                     |\n|-----------------------------|--------------------------------------|------------------------------|\n| **boilerplate_function_map** | `the_hole_value()`                   | 表示既没有 prototype 也没有 initial_map |\n| **function_map**             | `prototype` 对象 (JSObject)          | 一般是普通函数的 `.prototype` |\n| **constructor function_map** | `initial_map` (Map)                  | 作为构造器时，用于新建实例的 hidden class |\n| **strict/arrow function_map** | `the_hole_value()` 或 undefined       | 箭头函数/严格模式下不暴露 prototype |,0,Code Walkthrough,,0e8697aa-956c-4b43-9989-9c7b0a8ca819,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects-inl.h,,1666:0-1667:39,读取 obejct-slot 为 Object*,"Object* JSFunction::prototype_or_initial_map() {\n  return Object::cast(READ_FIELD(this, kPrototypeOrInitialMapOffset));\n}\n\nvoid JSFunction::set_prototype_or_initial_map(Object* value) {\n  WRITE_FIELD(this, kPrototypeOrInitialMapOffset, value);\n  WRITE_BARRIER(this, kPrototypeOrInitialMapOffset);\n}",0,Code Walkthrough,,cdc39590-241c-4dd4-ae77-fba442aadd36,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects-inl.h,,1681:9-1681:44,Object* 判断自己是否是 Map 类型,,0,Code Walkthrough,,e2f3f719-11dc-4b94-aeff-499a9b60018f,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2009:13-2009:35,返回当前 Map 里为这个对象类型预留的 还没使用的槽位数量。,在 V8 里，JS 对象的属性存储有两种模式：\n\n快属性 (fast properties)\n就像 C++ struct 一样：对象头后面直接有一段固定槽位（slots），每个属性对应某个偏移位置。\n优点：查找超快（直接用偏移量访问）。\n缺点：属性数量一旦超过预先分配，就要“搬家”。\n\n慢属性 (dictionary mode)\n对象变得像哈希表：属性存放在一个字典里，支持无限扩展，灵活但速度慢。\n\n所以 V8 的 strategy 是：\n能用快模式的时候，尽量保持在快模式 → 遇到属性频繁变化或太大才退化到慢模式\n\n\n既然 fast 模式用的是 固定槽布局，那么问题来了：\nJS 对象天性是动态的，怎么能预知用户还会不会加新属性？\n解决方案：在对象创建时留一些“余量槽位 (unused property fields)”。\n这样：\n对象新增几个属性时，可以直接用剩下的槽，不需要换 Map、不需要迁移内存。\n当槽位全部用光，再新增属性，就触发 Map 迁移，可能还要扩容或退化到 dictionary mode。\n,0,Code Walkthrough,,d934d89f-36ef-4635-b4ce-15816e52ce71,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2013:2-2014:39,bit_field 就是 对象行为的布尔开关集,,0,Code Walkthrough,,1a055318-2489-47e3-8d94-fe93e7666fa2,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2017:7-2017:25,kHasSpecialLookup 是一个 位偏移常量，表示 第几位 专门用来记录 “special lookup”。,,0,Code Walkthrough,,1341c3ce-f6cf-48e0-b983-887eb8f057b4,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2030:2-2031:43,特殊情况：prototype 不是对象。比如它是数字,如果 prototype 不是对象，就忽略，实例挂到默认 Object.prototype 上。,0,Code Walkthrough,,fad1d331-5873-41d0-a7b3-e737693e281b,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2033:2-2037:3,隐藏层，例如：myArr → [HiddenArrayStuff] → Array.prototype → Object.prototype,这里 [HiddenArrayStuff] 就是一个真实存在的对象（在 V8 内部，它有自己的 Map，如果你能偷看内存结构能看到）。\nmyArr.[[Prototype]] 指针 → 指向 [HiddenArrayStuff]。\n再往上：[HiddenArrayStuff].[[Prototype]] = Array.prototype。\n换句话说：在底层，这一层确实参与了 [[Prototype]] 链。,0,Code Walkthrough,,72f1a5c5-f623-4179-aa7d-e1c0037f2a85,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2044:0-2045:0,Named interceptor → 拦截形如 obj.foo 这种「名字属性」。,拦截器一旦存在，属性访问就必须「走慢路径」（触发 C++ handler），JIT 优化不能简单用 offset 直接取值了。,0,Code Walkthrough,,cffd72ba-5cd6-4be7-b0f0-12c370370461,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2053:0-2054:0,Indexed interceptor → 拦截形如 obj[123] 这种「下标属性」。,,0,Code Walkthrough,,a18105e6-244c-4a3a-89ea-d7827157735d,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2067:2-2069:3,标记某个对象是 undetectable object（不可检测对象）。,"名字：is_undetectable\n用途：标记某个对象是 undetectable object（不可检测对象）。\n效果简述：\ntypeof 这个对象 → 返回 """"undefined""""\n在布尔上下文里 → 结果是假 (false)\n其它方面，它却仍然是一个正常 JS 对象，可以有属性，可以调用。\n也就是说，这是一类**“披着隐身衣”的对象**：\n表面上看像 undefined，但在用作对象时却能工作。",0,Code Walkthrough,,3c077a1d-27b8-4b8d-b66d-9271383c4f06,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2075:2-2078:3,标记「某个对象是否带有 call‑as‑function 处理器 (Call‑As‑Function Handler)」。,开发者可以用 ObjectTemplate::SetCallAsFunctionHandler() 给一个对象挂上“当作函数调用时执行的 C++ 回调”。\n\n举个 C++ 假例子：\nobj_template->SetCallAsFunctionHandler(MyCallback);\n这就意味着，在 JS 里：\nconst obj = /* C++ 传回来的对象 */;\nobj(123);  // 不报错，会调用 MyCallback,0,Code Walkthrough,,b5355372-4c37-4033-9e0e-ac3fa6a35222,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2086:2-2088:3,标记「这个对象在访问其属性时，需要做安全检查 (access check)」。,典型场景：\n\n跨 iframe / 跨 window\n如果你在 iframeA 里拿 iframeB.window.document，直接访问可能违反同源策略。\nwindow 对象的 Map 就可能带上 needs_access_check，然后 V8 调用安全检查逻辑（通常交给浏览器的 embedder 回调）。\n\n宿主对象 (host objects)\n比如 process（Node.js）或 window.navigator（浏览器），某些属性受限，访问前需要校验。\n\nEmbedding API\nV8 C++ API 允许宿主程序提供安全检查回调 V8::SetAccessCheckCallbacks。\n当对象的 Map 被标记 needs_access_check = true，访问属性时就会触发这些回调，由宿主决定是否允许。,0,Code Walkthrough,,8c48accf-477b-4729-8b27-380e1e0e9ea8,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2095:2-2095:35,prototype 是「类的信息」，不应该存在每个对象身上，而是放在隐藏类 (Map) 上。,,0,Code Walkthrough,,fbce1e9f-3937-45a3-9dca-5a2536277025,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2148:2-2148:24,对象的 slot，分配空间时会分配的,,0,Code Walkthrough,,5aaf0a4e-0ff2-4b1b-aee4-ffd6962a0899,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2163:2-2163:33,bit field 每个 bit 位置的说明,,0,Code Walkthrough,,e26d32fc-8798-4fb7-baf8-c606bcebaa29,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2157:1-2157:62,kInstanceAttributesOffset 是 Map 对象头里「attributes 区域」的起始偏移。,"kInstanceAttributesOffset 是 Map 对象头里「attributes 区域」的起始偏移。\n在这片区域里，每个字节的意义固定：\n字节位置	名字	意义\n+0	kInstanceSizeOffset	当前 Map 的实例大小（对象有多大，要分配多少字节）\n+1	kInstanceTypeOffset	当前 Map 描述的对象类型（JSObject、JSFunction、String、Array…）\n+2	kUnusedPropertyFieldsOffset	(fast mode 对象) 预留多少未使用的属性槽数量\n+3	kBitFieldOffset	一堆布尔/小枚举标志的压缩位（is_extensible, has_interceptor, etc.）",3,Code Walkthrough,,990e03f0-6804-453b-99ac-5975392a9c01,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2371:2-2372:49,"普通函数（没有new调用过的）这里直接存函数原型。当遇到new调用时这里存 initial_map, 然后原型从 initial_map 里再读取 ",但是在 JSFunction 的 C++ 对象里，只留了一个槽 prototype_or_initial_map。\n\n那么怎么既能存 .prototype 对象，又能保存 initial_map 呢？\n\n👉 答案是：不是真正二选一，而是在不同阶段 / 不同 tag 下，存的东西不同，访问时靠 Map 的额外 bit 区分。\n\n在函数还没被当构造器用过时：\n这个槽里放的只是一个 JSObject —— F.prototype。\n（用户在 F.prototype 上加方法时，就是直接改这里指的对象）\n\n当函数第一次被 new 用作构造器时：\nV8 会 lazy 创建一份 initial_map（描述实例 shape、原型、大小等）\n然后把这份 Map 塞进 prototype_or_initial_map 槽。\n→ 用户层面这时访问 F.prototype 时，V8 会转到 initial_map 的 prototype 槽去拿。\n（所以表面看你还能读到 .prototype，只是内部实现换了“取法”）\n\n也就是说：同一个槽位，在“不同时期”扮演两种角色\n\n初期：直接存 prototype 对象。\n构造用过以后：存 initial_map，其中 initial_map 里再含有 prototype 指针。,3,Code Walkthrough,,5e3b99a6-68e2-49c6-8662-7d7486b73196,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,377:23-377:31,函数中内部定义的字面量,,0,Code Walkthrough,,1907ba7c-0be3-4c51-9ee6-3a98a93a59b3,0
9604e629901f2248e2812510252653985b87dfdc,/src/heap.cc,,1036:2-1038:45,创建1个Map，它记录了 JSFunction 的大小。并无特别之处,,0,Code Walkthrough,,24f38be8-5785-4009-9925-d16d9484b5bd,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,391:2-394:33,关键就在于 这个 the_hole_valu()。JSFuntion 判断知己是哪种类型的 JSFunction。可以靠 Map 类型，再就是这个槽位里的 *Object 是什么类型来解决的,\n| 使用的 Map                  | 槽位里存什么                         | 语义解释                     |\n|-----------------------------|--------------------------------------|------------------------------|\n| **boilerplate_function_map** | `the_hole_value()`                   | 表示既没有 prototype 也没有 initial_map |\n| **function_map**             | `prototype` 对象 (JSObject)          | 一般是普通函数的 `.prototype` |\n| **constructor function_map** | `initial_map` (Map)                  | 作为构造器时，用于新建实例的 hidden class |\n| **strict/arrow function_map** | `the_hole_value()` 或 undefined       | 箭头函数/严格模式下不暴露 prototype |\n,0,Code Walkthrough,,c3a9aefe-e12c-41c6-ab8d-93a0f9ddb652,0
9604e629901f2248e2812510252653985b87dfdc,/src/heap.cc,,1204:2-1206:24,hole 在 V8 里也是一个对象（HeapObject），全局单例,**Oddball（怪值）** 是 V8 专门为 JS 中的几类特殊值定义的一类对象，比如：undefined、null、true、false、hole、等等。,0,Code Walkthrough,,a11e02cb-f46b-4a2b-bd15-da25f251faf6,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects-inl.h,,1630:0-1632:1,JSFunction 是“样板函数”,,0,Code Walkthrough,,15dfa06d-5414-485d-99aa-f47d2f69af9f,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects-inl.h,,1680:5-1680:34,"JSFunction 有 initial_map, 说明它是构造函数",,0,Code Walkthrough,,0f5ca8c6-e95c-4084-9184-73b05910067e,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects-inl.h,,1695:0-1696:0,直接取原型或者从 initial_map 中取原型,,0,Code Walkthrough,,c1e24ffd-0f6b-46c8-87dd-f0d639c1f557,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects-inl.h,,1685:5-1685:41,instance prototype = “它当爸爸妈妈时，孩子们继承的基因模版” (Foo.prototype)。”,,0,Code Walkthrough,,9b76b63b-414d-4749-940c-3385849b1c9d,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects-inl.h,,1690:5-1690:31,这个 Function 有 prototype 不是对象或者它有 prototype，且它为对象,,0,Code Walkthrough,,10547714-00c4-4547-a139-c0d922f599c5,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects-inl.h,,1704:0-1705:0,因为 prototype 不是对象，constructor 又是在 prototype上取的。所以 constructor 就没有用了，用来存non-JSObject值,,0,Code Walkthrough,,51e49892-05bf-4c1f-88d8-4c039a16b8d1,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.cc,,3662:4-3662:34,返回函数内部定义的字面量数量,,0,Code Walkthrough,,ff95fd64-509f-40a3-bb52-e1498167073f,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2401:2-2403:32,JSFunction 作为构造函数时，有 initial_map,,0,Code Walkthrough,,46593cb8-8091-469a-b935-0f4e152ea734,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,2387:2-2388:36,调用它关联的 SharedFunctionInfo 存储 Code,,0,Code Walkthrough,,746d1e0c-43a5-4f38-8aec-950360559103,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,409:2-415:3,直接强制它是一个构造函数,,0,Code Walkthrough,,dab912d8-338b-4a1f-a96a-12c1e8595c72,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.h,,94:5-94:23,V8 内部定义的 属性标志位 (PropertyAttributes)。它们用来描述 对象属性的特性（可读写、可枚举、可删除…），对应了 JS 规范里的 PropertyDescriptor 里的 writable、enumerable、configurable 等，但在 V8 实现里被设计成了一组 bit flag,"NONE (0) → 默认属性；可写、可枚举、可删除（writable: true, enumerable: true, configurable: true）。\nREAD_ONLY (1) → 不可写；对应 ECMAScript 的 writable: false。\nDONT_ENUM (2) → 不可枚举；对应 ECMAScript 的 enumerable: false。\nDONT_DELETE (4) → 不可删除；对应 ECMAScript 的 configurable: false。\nINTERCEPTED (8) → V8 内部标志，用于表示属性经由拦截器（interceptor/handler）提供。\nABSENT (16) → V8 内部标志，用来表示属性不存在（和值是 undefined 区别开）",0,Code Walkthrough,,fb0dd8f5-8396-4172-ae7a-02b201dc8e96,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,420:2-420:77,为函数的 prototype 添加  consturctor 属性。不可枚举意味着 for...in 等是取不到的,不可枚举 就是：对象的这个属性在 JS 的“枚举（列举属性）”操作中被跳过。枚举操作包括：\nfor...in 循环\nObject.keys()\nObject.entries()\nJSON.stringify()（默认只序列化可枚举属性）,0,Code Walkthrough,,398bae13-55dc-4c1d-9e89-ebaeed7a0261,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,398:28-398:52,创建函数，同时设置它的 prototype,1. 普通函数字面量的 .prototype 是一个新建的普通对象（Object 实例），里面有 constructor 指回函数本身。\n2. 箭头函数 / 方法简写没有 .prototype（访问是 undefined）。\n3. 类声明和普通函数一样，有一个新建的普通对象，带默认的 constructor 属性。,0,Code Walkthrough,,09200b95-3048-406b-93a7-6a36f7a95e1c,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,597:28-597:39,创建顶层函数同时设置好它的 prototype,,0,Code Walkthrough,,4eef48db-0bfd-412e-a5a1-d89849439b23,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,587:28-587:45,分配一个函数，普通函数。并配置上 prototype。,,0,Code Walkthrough,,bb4da61d-5d32-4cf7-9c67-db9acb3af1b7,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,574:36-574:57,分配 SFI 对象到 Heap,,0,Code Walkthrough,,92001169-e452-41d9-8eaf-85250daf0a11,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,371:28-371:50,创建函数：生成样板函数，例如函数字面量、闭包都可以调用它先创建样板函数,,3,Code Walkthrough,,f0f17d4d-c65c-4ddd-b78b-75767a3a0955,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,195:28-195:54,创建函数：从样板函数创建出来 JSFunction,,3,Code Walkthrough,,fc59a903-c1eb-46b8-acd6-3d01eca4ace8,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,345:28-345:39,创建函数：使用场景主要是内建函数。创建顶层函数,,3,Code Walkthrough,,d47df860-063d-4989-84fb-f6f55d943f49,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,199:0-200:0,为样板函数中设置 Top::function_map(),,0,Code Walkthrough,,804a2b77-a831-4eb4-9f38-aa48ba0c2383,0
9604e629901f2248e2812510252653985b87dfdc,/src/factory.cc,,188:2-191:33,function_map 告知分配JSFunction空间的大小，然后申请完了之后。JSFunction 的 Map 指向它,,0,Code Walkthrough,,763ac67a-3106-4474-86f2-31ba63e0b04c,0
9604e629901f2248e2812510252653985b87dfdc,/src/heap.cc,,1628:45-1628:53,function 刚刚从空间分配，SFI 和样板共享。其他见下文，都比较直观,,0,Code Walkthrough,,15743cec-3f00-406f-a84f-c3edde653040,0
9604e629901f2248e2812510252653985b87dfdc,/src/objects.cc,,3700:4-3700:34,设置 prototype 时，遇到不是对象的情况，存储到 constructor,,0,Code Walkthrough,,36edd8e2-0430-4f68-a234-b45271852804,0
9604e629901f2248e2812510252653985b87dfdc,/src/codegen.cc,,103:19-103:50,main.js 文件中定义函数走到这里解析， code 是懒编译。返回1个JSFunction,,0,Code Walkthrough,,9bc1312a-1339-44bd-b302-021ad85d837a,0
9604e629901f2248e2812510252653985b87dfdc,/src/codegen-ia32.cc,,3246:17-3246:37,遇见函数字面量定义函数时，也就调用 Runtime::kNewClosure 了,,3,Code Walkthrough,,9efa0cd8-6d4d-45bb-815f-da502bec85ad,0
9604e629901f2248e2812510252653985b87dfdc,/src/codegen-ia32.cc,,3246:5-3246:41,"生成函数字面量，调用底层 CallRuntime(Runtime::kNewClosure, 2) 定义函数",,0,Code Walkthrough,,0cda8d71-0efb-4ac0-b3ce-f89c80b4fcb0,0
9604e629901f2248e2812510252653985b87dfdc,/src/runtime.cc,,2615:15-2615:33,汇编调用它创建1个新的 js 函数,,0,Code Walkthrough,,4da9c893-e88b-48d4-b1e2-2e0a516e9a90,0
9604e629901f2248e2812510252653985b87dfdc,/src/codegen-ia32.cc,,3262:24-3262:55,这是 AST 中另外一个节点类型，用来表示“已经有现成的 boilerplate 函数对象” ，只需要在运行时克隆 closure。,有时候内部编译器会复用已经生成好的 boilerplate，把它包装为一个 FunctionBoilerplateLiteral 节点，避免重复 Build。,0,Code Walkthrough,,1e99ecfa-6788-468e-9873-c98e7a3e85a0,0
9604e629901f2248e2812510252653985b87dfdc,/src/codegen-ia32.cc,,2529:0-2530:0,Reference target(x)    ; proxy -> variable -> slot = STACK index0,,0,Code Walkthrough,,b1224234-58fa-447f-8991-69111ddf042c,0
9604e629901f2248e2812510252653985b87dfdc,/src/codegen-ia32.cc,,2478:24-2478:40,调用 Load -> LoadCondition -> Visit 触发子节点调用 Visit 了,,0,Code Walkthrough,,7114d0d9-1b65-48ca-b7ec-2721e2433015,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/runtime.cc,,107:15-107:53,同一个函数被调用多次（每次函数执行到 object literal）。首次调用的时候创建样板对象,函数编译时：只生成 runtime call 指令，不建对象。\n第一次执行到 object literal：runtime 创建 boilerplate（模板对象），存入 literals array。\n后续执行：直接 clone boilerplate 生成新对象，避免重复构造。\n这种懒初始化 + 缓存 = 节省了编译时和运行时的开销。,0,Code Walkthrough,,37ac9d8e-416f-4257-b588-20127532079f,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/codegen-ia32.cc,,3535:5-3535:42,生成对象字面量,,3,Code Walkthrough,,4fdc8093-b786-4d3e-ad3c-df5ca4f1aa75,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/codegen-ia32.cc,,3520:5-3520:26,它所在函数被首次调用时创建字面量模板,,0,Code Walkthrough,,eef91c7e-fa8f-4065-b079-d02646dafe86,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/runtime.cc,,4920:33-4920:62,定义结构体数组，它保存了函数地址,,0,Code Walkthrough,,ce01babc-da0b-4a29-8f33-e635c769d7c0,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/runtime.h,,40:8-40:36,Runtime 函数，例如  DeclareGlobals,,0,Code Walkthrough,,fbea6c1c-6dbf-4943-a019-2bc91f890822,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/runtime.cc,,4931:42-4931:52,FunctionId 它是枚举，包含所有的 Runtime 函数,,0,Code Walkthrough,,32906b72-d7ac-48a6-b9f9-6901aec91327,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/runtime.h,,326:4-326:16,v8::internal::Address 就是 byte*,,0,Code Walkthrough,,ed3a6405-c888-4d01-8980-d7807ac3f6f4,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/globals.h,,408:0-409:74,"Address 是 byte*, byte* 方便做偏移运算。",intptr_t 是一个 能容纳指针大小的整数。\n把函数指针 f 转成 intptr_t → 就变成一个数值形式的「裸地址」。\n然后再把这个整数 reinterpret_cast 成 Address (byte*) → 数据地址表示。\n这样做的好处是：\n- 避免函数指针和数据指针的直接 cast → 保证跨平台一致。\n- 以整数为过渡，表达明确：“我就是想拿到裸地址值”。\n实际效果就是：“我只要它的数值，不在乎类型”。,0,Code Walkthrough,,f91f67a4-3202-4429-9c2e-3a5f1356fbf1,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/globals.h,,77:0-77:22,byte* 方便位移,,0,Code Walkthrough,,d0946100-9092-4ddf-beba-cb1235635019,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/macro-assembler-arm.cc,,597:44-597:51,比如枚举 kDeclareGlobal 的 int 值,,0,Code Walkthrough,,c0d4fddf-6e68-4c16-a022-e11454024329,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/codegen.cc,,276:18-276:26,例如 _id 是枚举 kDeclareGlobal 的 int 值。表示每个 Runtime 函数都有独立的 Stub 入口,,0,Code Walkthrough,,e3a554c1-3ee1-41bc-a99e-182f815b546b,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/assembler.h,,397:6-397:23,ExternalReference 表示一个 C++ 地址，在生成的机器码里会去调用它。 为了追踪所有调用外部函数的来源，V8 强制用 ExternalReference 来封装所有 C++ 函数 / 变量 / 全局数据的地址。,,0,Code Walkthrough,,cf032d7a-5087-4590-a658-ba8ec2679df7,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/assembler.cc,,515:0-516:25,"包一层 Runtime 函数的地址, f->entry 就是 C++ 函数的入口",,0,Code Walkthrough,,024377e9-085d-43ab-983b-809d03754a0d,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/macro-assembler-ia32.cc,,567:21-567:34,跳转前往的函数地址放到 ebx 中,,0,Code Walkthrough,,1fde4d43-44a1-48e5-bfe7-9738c0e5ff31,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/execution.cc,,74:4-74:21,从 C++ 世界进入 JS 世界。反之 JS 进入 C++ 世界会用 CEntryStub,,0,Code Walkthrough,,25ec33fa-6ea3-4c69-b4f7-fb4fb496d40b,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/codegen.h,,180:6-180:17,生成机器码调用 Runtime 函数的桥接入口，底层实现是 CEntryStub,,0,Code Walkthrough,,6fb957ab-70f6-4a77-95aa-a5d092d820b1,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/codegen-ia32.cc,,4990:17-4990:29,直接生成1个C的frame,"## 📝 串联一个调用示例\n假如 JS 执行 `x = obj.prop;` miss 了，需要 runtime lookup：  \n\n1. JIT 代码 call 进入 `CEntryStub`  \n2. `GenerateBody` → 建 ExitFrame  \n3. `GenerateCore` → call &Runtime_GetProperty(argc, argv)  \n4. Runtime C++ 执行，返回一个 JSValue 或 Failure  \n5. `GenerateCore` 判断返回：\n   - 正常 → eax 已经是值，执行 epilogue，`ret` 回 JS  \n   - OOM → 跳 `GenerateThrowOutOfMemory`  \n   - 普通异常 → 跳 `GenerateThrowTOS`  ",0,Code Walkthrough,,f58ad404-055b-4041-9c67-9cc200fbad91,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/codegen-ia32.cc,,5051:2-5051:18,entry: 就是一个局部标签，相当于汇编里 entry:。可以 jmp entry，重新从这儿开始执行。,\n在 IA32/x64 上，像 `jmp label`、`je label` 这类跳转指令，都是存一个 **相对偏移 (relative displacement)**：\n\n```\njmp rel32    → 机器码 E9 xx xx xx xx\n```\n\n其中那 4 字节 `rel32` = (目标地址 - 下一条指令的地址)。\n\n也就是说，CPU 并不存 label 名，只有“往前/往后跳多少字节”。,0,Code Walkthrough,,fdc25d54-fab7-49e4-a4c8-026c8ec064d9,0

a488203bde9325fcca6200abe9510ffb7c324f7c,/src/codegen-ia32.cc,,5053:2-5054:31,先声明标签,,0,Code Walkthrough,,de838c56-949a-4577-9037-c5dfa485e47a,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/codegen-ia32.cc,,5078:2-5078:42,后定义标签的位置,,0,Code Walkthrough,,4148a30d-2883-4933-bf42-aac94c34f114,0
a488203bde9325fcca6200abe9510ffb7c324f7c,/src/codegen-ia32.cc,,5072:2-5072:14,如果 runtime 调用时内存不够，它可以先返回一个特殊的 Failure，要求先做 GC，再重新执行一次 runtime 调用。,,0,Code Walkthrough,,9c4f3577-e978-424a-9a6e-3e2ba399fe20,0


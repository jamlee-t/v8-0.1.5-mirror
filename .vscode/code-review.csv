sha,filename,url,lines,title,comment,priority,category,additional,id,private
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/bootstrapper.cc,,450:20-450:45,存储 new Function 创建的函数,-,0,Code Walkthrough,,c981767a-c248-487b-981c-64fd1fa2e2f2,0
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/bootstrapper.cc,,470:16-470:31,initial_map 是构造函数的初始映射,initial_map 是构造函数的初始映射，它定义了当这个函数作为构造函数使用时（通过 new 操作符调用）创建的对象的基本结构和属性。,0,Code Walkthrough,,1baaf95d-80b7-49bf-87d6-bcfa1684b28b,0
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/builtins.h,,176:35-176:44,Builtins::Setup() 中设置的数组,-,0,Code Walkthrough,,2fa9d20b-269d-4d87-b8d2-8045c1ae9d8e,0
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/factory.cc,,53:27-53:39,安全地调用可能触发垃圾回收的堆操作函数,,0,Code Walkthrough,,a1976046-8450-45a2-9184-158f081c2484,0
2892a07ced9ce7b0c8da1b7aa5a28ab7823567dc,/src/bootstrapper.cc,,487:26-487:61,调用到堆的符号查找机制，确保相同字符串的Symbol只创建一次，实现了Symbol的唯一性,"""""在堆中查找Symbol""""的含义是：在存储于堆内存中的符号表数据结构中查找或创建Symbol对象。这是V8实现Symbol唯一性和高效管理的核心机制。\n\n查找不慢吗?\nV8中的Symbol查找基于哈希表实现，具体在 SymbolTable 类中。",0,Code Walkthrough,,dd807642-364b-4e3a-a9b5-6ba28f4f5bb3,0
aeef99615dea0e7a12c43fa7f392af290b54381c,/src/api.cc,,830:22-830:41,构造时创建的的指针是 ObjectTemplateInfo,构造时创建的的指针是 ObjectTemplateInfo。创建完成后用 ToLocal 转回为 ObjectTemplate,0,Code Walkthrough,,ad13c2ca-35df-49d6-984f-29712d032cc9,0
7a84c50ed1fd12abd3f4072da5224ce299780f11,/public/v8.h,,389:8-389:12,存储当前 HandleScope 的指针,在 HandleScope::Data 类中，next 和 limit 是用于管理句柄块（handle block）中句柄分配的关键指针。 v8.h:389-398\n\nnext 和 limit 的用途\nnext 指针\nnext 指向当前句柄块中下一个可用的句柄位置。 api.cc:362-400 当创建新句柄时，CreateHandle() 函数会：\n\n将 current_.next 的值作为新句柄的存储位置\n在该位置存储句柄值\n将 current_.next 递增指向下一个位置\nlimit 指针\nlimit 指向当前句柄块的末尾边界，用于检测当前块是否已满。 api.cc:364-391 当 result == current_.limit 时，表示当前块已满，需要分配新的扩展块。\n\n工作流程\n句柄分配的完整流程如下：\n\n检查空间: 比较 next 和 limit 判断当前块是否还有空间\n分配扩展块: 如果空间不足，通过 GetSpareOrNewBlock() 获取新块\n更新指针: 设置新的 limit 指向新块的末尾\n分配句柄: 在 next 位置存储句柄值，然后递增 next\n初始化状态\n在 Initialize() 方法中，next 和 limit 都被设置为 NULL，extensions 设置为 -1，表示初始状态下没有可用的句柄块。 v8.h:394-398\n\nNotes\n这种设计实现了高效的线性分配策略，通过简单的指针比较和递增操作来管理句柄分配，避免了复杂的内存管理开销。当句柄块用完时，系统会自动扩展到新的块，确保句柄分配的连续性。,0,Code Walkthrough,,0edace07-55c3-4587-9307-396160093603,0
7a84c50ed1fd12abd3f4072da5224ce299780f11,/public/v8.h,,870:5-870:22,JS 里设置属性描述符,"const obj = {};\n\nObject.defineProperty(obj, """"x"""", {\n  value: 42,\n  writable: false,     // 对应 V8 的 ReadOnly\n  enumerable: false,   // 对应 V8 的 DontEnum\n  configurable: false  // 对应 V8 的 DontDelete\n});\n\nconsole.log(obj.x);   // 42\nobj.x = 100;          // 静默失败（非严格模式），严格模式抛 TypeError\ndelete obj.x;         // false，删除无效\nconsole.log(Object.keys(obj)); // []",0,Code Walkthrough,,9d000a5f-fb01-4193-abd2-79f66a38ae23,0
7a84c50ed1fd12abd3f4072da5224ce299780f11,/src/api.cc,,405:54-405:54,v8::Context 转为 v8::Internal::Context,,0,Code Walkthrough,,ddce0a9f-6540-48c6-a618-1c78c4a6f214,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/api.cc,,2106:0-2107:0,为 global object 补齐 “constructor ” ,这是 V8 给 global object 补齐“constructor <-> instance”对的安全垫，保证它和其他对象一样遵守 FunctionTemplate–ObjectTemplate 的统一机制。,1,Code Walkthrough,,014eb811-6e05-4c37-b0bd-7379ca5b340a,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/log.h,,77:6-77:13,描述VM的四种状态，仅仅是及状态,VMState 实现了一个状态栈机制，用于跟踪 V8 引擎在不同执行阶段的状态：\n\nJS - 执行 JavaScript 代码\nGC - 垃圾收集\nCOMPILER - 编译代码\nOTHER - 其他操作（如 API 调用、拦截器等）,0,Code Walkthrough,,250d1a7c-a093-4f72-be79-c4395ce0b554,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/log.h,,190:25-190:25,采样数据通过 Profiler 线程被写入到日志文件中,采样数,0,Code Walkthrough,,54a3b5cb-f23f-4d25-ac8c-11746a73ec06,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,105:0-105:38,半空间大小，也就是 From 和 To 的大小。2 *  semispace_size_ 是年轻代空间大小,,0,Code Walkthrough,,870affd7-dc29-4a41-b4c6-d4194e515fb8,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2497:2-2498:73,申请双倍的内存，里面找到对齐的地址作为新生代。,内存布局上：OldSpace 放前面（因为对齐要求在 NewSpace，并且 OldSpace 起始大小小，便于腾出对齐地址）。\n容量大小上：OldSpace 最终会比 NewSpace 大很多（几十倍甚至几百倍），因为所有长寿命对象+代码+Map 最终都晋升/常驻在老生代。,0,Code Walkthrough,,f6d9a97b-9f85-4186-98f2-d8a8f25c3c63,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2507:0-2508:0,old_space_start 是申请的地址起始。然后找到对齐的 young_generation_size_ 地址,在 old_space_start 的基础上，找到一个大于等于它的地址，并且保证这个地址是 young_generation_size_ 的整数倍。\n\n,0,Code Walkthrough,,8c089c37-f52c-4bc1-9eba-21a1763df172,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2510:24-2510:63,new_space 过后是  code_space_start，code_space_start + code_space_size,chunk 总大小是 young_generation_size_ * 2。 young_generation_size_ - old_space_size 自然是剩余的 code_space_size,0,Code Walkthrough,,470e035d-3cdf-4b29-9f82-86aea1706ab8,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2513:19-2513:69,initial_semispace_size_ 是起步规模，不用一开始用最大的空间,,0,Code Walkthrough,,6a3c2ee8-98d5-4a3d-a326-c68efda12462,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2519:19-2519:60,old_space_size 是实际起点大小,old_generation_size_ = 老生代允许的最大容量（总配额 / 上限）。\nold_space_size = 初始化阶段从初始 chunk 里切出来的那一块起步空间（实际起点大小）。\n老生代会从 old_space_size 起步，逐步扩展，最多扩到 old_generation_size_。\n,0,Code Walkthrough,,e0d0556a-9dd7-465b-92b3-d56f5aaf7695,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2530:19-2530:27,Map 是对象系统的类型元数据，生命周期长、访问频繁、GC 必须依赖它们，所以 V8 把 Map 单独放到 MapSpace，保证稳定性和效率。,,0,Code Walkthrough,,11c10212-40a0-45c8-92e8-e88fc38d8829,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2536:18-2536:34,典型应用场景：大数组、大字符串、大 TypedArray,,0,Code Walkthrough,,26ef3124-b48a-4208-8687-05b694d08331,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/heap.cc,,2543:9-2543:25,CreateApiObjects() 只是创建 neander_map_、message_listeners_ 和 debug_event_listeners_ 三个东西。,,0,Code Walkthrough,,af9566d7-58f9-4098-b028-eb7208d7a157,0
16eeebb54adbdb226185b94e7e8ad03f5fb639d3,/src/bootstrapper.cc,,1093:4-1093:18,合并 ObjectTemplate 创建的对像和传入的 global 对象,,0,Code Walkthrough,,0c9424f1-9ecc-417f-944a-1794121fb731,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/factory.cc,,119:24-119:33,从 Heap 中分配 Struct 所需的空间,,0,Code Walkthrough,,6fe413e8-3e93-4950-9731-73395b647b77,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/heap.cc,,2159:0-2159:11,定义 STRUCT_LIST 的 switch。找到访问 map 的函数，例如 Scirpt 类是 scirpt_map(),,0,Code Walkthrough,,d5ad1933-ca6a-4d77-b120-962d01263817,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/heap.h,,748:2-748:13,定义 STRUCT_LIST 的 Map 实例。提供对象的访问 Map 函数使用,,0,Code Walkthrough,,f8f41e23-b319-4b13-a774-b1365ad78292,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/heap.h,,566:2-566:13,定义 STRUCT_LIST 访问函数。例如 script 是 script_map,,0,Code Walkthrough,,382fa3c8-5192-4346-9fc5-4f4ef79a8fca,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/heap.cc,,1020:2-1020:31,初始化 STRUCT_LIST 声明的 Map。,,0,Code Walkthrough,,87432f1a-8868-4f10-91ea-38fac6de33b8,0
12841db942f1014a9c81a70b9390d683a12eae72,/src/objects.h,,2224:19-2224:32,这里的 kSource/kName是来自它的成员属性定义，刚好 6个,,0,Code Walkthrough,,ac49f846-9c07-4c4d-b39d-6d764c38b85b,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/parser.cc,,737:19-737:26,它是 ParserFactory,,0,Code Walkthrough,,ac4d9473-ac69-49e2-9718-6b4cc8f6c202,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/parser.cc,,541:27-541:35,类成员按照声明顺序调用构造函数。初始化列表的顺序不影响真正调用顺序。,\n类类型成员：如果有默认构造函数且你没指定，编译器会自动调用。\n内置类型成员（int/double/raw 指针…）：不会初始化，值是未定义的。\n顺序：先基类 → 再成员（按声明顺序）。\n初始化列表只是改变默认方式，否则类成员总会构造。\n\n\n\n构造时：Base → MemberA → MemberB → Derived\n析构时：~Derived → ~MemberB → ~MemberA → ~Base\n\n\n,0,Code Walkthrough,,c7fa5282-a46d-4bf2-9f57-ea7ba9012d4f,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/scopes.h,,123:25-123:37,NewTemporary 函数用于创建编译器内部使用的临时变量，主要用于存储中间计算结果和编译器状态,,0,Code Walkthrough,,cc7c1398-857c-417b-baf2-55a637160e26,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/scopes.h,,131:5-131:35,非法重声明的错误表达式确实是在运行时执行到该作用域时才报错，而不是在解析时立即报错。,,0,Code Walkthrough,,b036b7d5-6e16-4dd7-a383-30805f72ca35,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/scopes.h,,173:17-173:25,receiver 在函数作用域里对应 “函数调用时传入的 this 值”。,,0,Code Walkthrough,,6d584dbb-db45-4269-b9cb-5f0ae5ab9315,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/scopes.h,,235:6-235:24,JavaScript 的闭包访问必须高效，所以 V8 在编译期就算好，“往上几层就是我要的变量”，到运行时直接按偏移量取，几乎是 O(1)。,,0,Code Walkthrough,,8feab2b1-ba75-4334-ac2f-dde85a89ca7f,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/scopes.h,,232:7-232:29,这意味着闭包里访问自由变量时，不需要多级查找，可以直接定位到全局。,,0,Code Walkthrough,,f857cfe8-35f1-4fba-8b9b-75744cd4cfa3,0
b11081c55b36bc7f0b402f7ece1db1a03be4e939,/src/scopes.cc,,163:36-163:61,定义 this 变量，脚本本身也有这个变量,,0,Code Walkthrough,,d313ef30-dd9a-46ac-b327-43371703fc37,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,215:22-215:35,先增加未解析的变量，后解析。支持同名，每个Unresolved 的是一个变量代理位置。,,0,Code Walkthrough,,ba38e3b8-bd4d-48fd-b728-0c396fd8732f,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,225:12-225:28,unresolved_ 中移除 proxy,意味着这个代理 Proxy 已经找到目标 Variable，可以退役了，不再算“悬而未决”的引用。,0,Code Walkthrough,,2a7a469c-81c5-4a97-8694-3d18b74eacb0,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,95:2-95:42,Proxy.scope_ = NULL 只表示“这个 Proxy 没有静态 owner，需要 runtime lookup”。,- Proxy 的 scope_ == NULL ≠ 我不知道父级是谁\n- 它只是编译时不能静态绑定变量\n- 建立 Context chain 的“上级是谁”靠的不是 Proxy.scope_，而是 Scope 对象本身的 parent 指针 (outer_scope_)，以及运行时调用点的 ExecutionContext\n\n换句话说：\n- Context 链是 scope 结构树决定的（词法作用域 + eval 调用点），不是某个 Proxy 的字段决定的。\n- Proxy.scope_ = NULL 只表示“这个 Proxy 没有静态 owner，需要 runtime lookup”。,0,Code Walkthrough,,6f91943e-cc49-4cda-9d6f-04f71bbb3924,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,246:12-246:26,Scope 之所以要保存声明 (Declaration)，是为了在解析和符号绑定过程中记录这一段代码里“显式声明了哪些名字”。,Scope 之所以要保存声明 (Declaration)，是为了在解析和符号绑定过程中记录这一段代码里“显式声明了哪些名字”。\n这是构建符号表（Variable 列表）的第一步，之后才能正确地进行变量解析、闭包捕获、上下文分配。\n,0,Code Walkthrough,,05428f73-0eb3-40d5-ac72-53c31b52b4e0,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,251:12-251:35,记录“第一次发现非法重声明”的出处（AST 节点）,保存非法声明的 AST 节点，方便后续 Visitor 抛出 SyntaxError 并指明具体错误位置。记录下来，再统一处理：这样 Scope 只负责“发现”，Visitor 负责“报错”，分工明确，错误定位信息完整。\n,0,Code Walkthrough,,c6e9572e-86da-45db-91a3-909752c0dce0,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,225:23-225:33,"比如遍历 Block, node->Accept --> Visit --> VisitBlock",,0,Code Walkthrough,,59e3e9dc-e747-49ee-8ffc-b4499cb3861e,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,1208:15-1208:30,Visitor 调用 VisitStatements 访问内容。也就是说 Statements 支持这个 Vistor 访问它,,0,Code Walkthrough,,bfa7b32a-36b5-40a3-a729-06b623145c8b,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.cc,,49:4-49:25,语法节点调用Accept，然后调用例如 v->VisitExpressionStatement ,,0,Code Walkthrough,,3cfdcb2f-caea-4a4f-91d9-71e211cac2b0,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,263:2-263:35,illegal_redecl 虽然是 Expression 抽象类，它可以调用虚函数 Accept。转发调用到底层子类,,0,Code Walkthrough,,dd2815f0-7a57-4b6e-931c-f7d5924df09b,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.cc,,166:4-166:29,Visitor 子语句,,0,Code Walkthrough,,4944ca00-59e8-4a83-9772-48ace18fc489,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,268:12-268:32,Scope 里面的临时变量和本地变量收集到参数 locals 中,,0,Code Walkthrough,,3e0ae72b-93a3-46ea-8a36-19c5f498b457,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,288:0-292:50,语法：显式实例化模板。C++98 标准就已经规定了,强迫编译器“马上生成指定类型的模板函数版本”，而不是等到别的地方用到时再生成。这样可以保证函数的定义在链接阶段一定存在。,0,Code Walkthrough,,3ce9b159-f4c1-4a55-b8e6-2e8bea9aeb3e,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,296:0-296:31,说明这个函数只会在 最外层调用：全局作用域或 eval 作用域。,,0,Code Walkthrough,,ddd3ef29-ec9c-4692-944d-eaaba4757d35,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,642:4-642:35,外部 scope 调用了 eval,,0,Code Walkthrough,,8097fab1-d663-4a5a-9622-fffaef5f6d05,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,649:6-649:29,内部 scope 调用了 eval,,0,Code Walkthrough,,6bb6b00b-ba0a-4331-a0dc-7430a78dbc64,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,304:2-304:20,标记整个 scope 树的 eval 传递,“如果链里的任何函数调用了 eval，整个链（从树根到这个枝叶）不就都要用 Context 了”\n是的，就是这样！\n这就是为什么引擎看到 eval，就要尽量保守，把整个 scope 链的变量都放 Context，这样 运行时 scope chain 查找 eval 里提到的名字，一定能成功。,0,Code Walkthrough,,1dfa486d-bdfe-44e4-be74-d9eb6da7094a,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,602:8-602:38,变量解析保持动态决议,,0,Code Walkthrough,,8e5f4584-6b52-44f4-b4d1-567f1d39a755,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,577:6-577:26,变量在 With 语句中,,0,Code Walkthrough,,ff84a963-1069-482a-88ee-6c14ec8a2508,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,307:2-307:29,global_scope = NULL 表示 “这里我不静态兜底到 global，保留动态决议”。,,0,Code Walkthrough,,806c6942-2fed-431d-949b-6a61dd543460,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,316:12-316:24,当前 scope 或者子 scope 调用了 eval,,0,Code Walkthrough,,f42f6089-6217-48dd-8804-7ad5008b8e39,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,508:17-508:32,从当前 scope 向父作用域递归查找name的变量定义,是的，这个函数本质就是 从当前 scope 向父作用域递归查找变量定义：\n\n本作用域里有没有 → 有就返回。\n没有 → 看是不是函数自名 → 否 → 去 outer_scope。\n如果沿途遇到 eval/with 干的 scope → 就只能返回 NULL，让 runtime 查。\n如果 inner scope 在查 → 顺便打 closure 捕获标记。,0,Code Walkthrough,,f5ed6347-fe91-4f71-910d-e2506eadd794,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,575:34-575:47,解析变量指已知当前 scope 的 proxy->name()，找到父级的Scope 中 locals 的定义变量,,0,Code Walkthrough,,23ee665b-d99b-4b96-8802-a8bfca05f5bb,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,625:12-625:39,解析当前 scope 的  proxy，找到指向的变量,,0,Code Walkthrough,,c7e70b63-2084-476a-8e03-152d1cecdda8,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.h,,270:0-271:0,当前作用域解析不了的变量，要找父级 scope。或者运行时动态解析,,0,Code Walkthrough,,63d5a066-e4c7-4b85-b3ec-aa5793fc79c0,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,630:11-630:11,解析当前 scope 未解析的变量,,0,Code Walkthrough,,f30a1582-9ff7-4872-9b77-5e0dc54e640f,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,535:8-535:17,function_ 就是“函数自己”的名字（function literal 的名字）。,,0,Code Walkthrough,,b475524e-1b35-47ed-a0ca-8fce41a9950f,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,309:2-309:29,unresolved_ 数组中的 proxy 绑定父级scope里的变量,,0,Code Walkthrough,,7b85d597-ec1f-4d91-8091-a0383730f092,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,312:2-312:30,var->rewrite_ 分配上 Slot,,0,Code Walkthrough,,6527ef15-76d8-435a-ab3e-397dc714188c,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,660:12-660:24,变量是否必须分配,Scope::MustAllocate(var) 的意义：\n\n检查一个变量是否必须在运行时拥有真实存储槽位（stack slot / context slot / global property），否则就可以优化掉。\n以下情况必须分配：\n被闭包捕获\neval 存在\nwith 存在\n是全局变量\n关键字 this\n一句话：\n👉 凡是 JS 语义上无法在编译期“完全静态确定”的变量，都必须在 MustAllocate 里被标记为 used，从而分配到 Context/Heap 或 Global。\n\n,0,Code Walkthrough,,c045b3ad-f09c-486a-acf3-29d32fc3d7ec,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,674:12-674:33,进一步判别它是不是必须放进 Context 对象 (heap)，而不是简单的 Stack slot (栈空间),,0,Code Walkthrough,,57449e15-b9e6-4ea9-a264-cb8ac79deba0,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,326:12-326:29, trivial context = 说明 scope 不需要真实的堆上的 context 对象，访问变量靠 stack/global 就够了。,沿着当前 scope → 外层 scope链 一直向上看：\n如果遇到 eval scope → 非 trivial\n如果遇到 with scope → 非 trivial\n如果该作用域本身有 heap slots（即 Context 变量） → 非 trivial\n如果以上都没有 → trivial。,0,Code Walkthrough,,3e761b6f-e8b5-4209-8c9b-e6e48f44c6dd,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,321:12-321:33,外部有 eval ⇒ 内层函数不能 lazy compile，,你之前问到的 AllowsLazyCompilation 的设计点就是：\n\n如果 outer 有 eval → inner 不允许 lazy compile，必须 eager compile。\n原因：\n懒编译意味着 inner 在第一次调用时才做完整解析 → 但那个时候，outer 已经可能执行过部分代码（包括 eval 插入过名字），这会导致 inner 的变量解析逻辑和 outer 的环境在时间上不同步 💥。\neager compile 的好处：在 outer 创建 inner 的那一刻，inner 就绑定好“outer 的 Context 环境引用”，保证后续运行时 eval 才能注入并被 runtime lookup 看见。,0,Code Walkthrough,,a3bc338f-c7ce-43aa-8309-06266ae2a07a,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,350:11-350:29,计算父级 Scope，只有 Scope 有 num_heap_slots 才计数为链长度,,0,Code Walkthrough,,44fc93b6-c5ff-4034-a117-d10c9ef87f23,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,340:12-340:34,outer_scope 是否全部都是 trivial context,,0,Code Walkthrough,,468e1b41-142e-4603-89e7-681249046eba,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,479:17-479:25,nonlocals_ = 作用域内“编译期不能静态绑定的标识符引用”集合,nonlocals_ = 作用域内“编译期不能静态绑定的标识符引用”集合。\n来自三大场景：\nwith → 属性遮蔽，无法确定绑定\neval → 动态插入/修改名字\n未解析（全局） → 留给 runtime global lookup\n编译器在生成代码时，对这些变量一律走 runtime lookup，而不是绑定静态 slot。,0,Code Walkthrough,,211018d3-64ff-4c00-85a9-687d90ac565d,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,689:12-689:33,"检查当前函数作用域的形参列表里有没有名字叫 """"arguments"""" 的参数。","Scope::HasArgumentsParameter() 的作用就是 ——\n\n检查当前函数作用域的形参列表里有没有名字叫 """"arguments"""" 的参数。\n如果有 → arguments 在这个函数体里只是一个普通变量，不再自动创建默认的魔法 arguments 对象。\n如果没有 → 按规范",0,Code Walkthrough,,f8566dff-6c75-4b30-955a-d2b06dc40d8d,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,698:12-698:29,给变量分配在函数栈帧的局部槽，最快。,,0,Code Walkthrough,,1733ac27-100f-45e4-98fe-9d3323b040b1,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,703:12-703:28,给变量分配在堆上的 Context 对象，能跨函数作用域共享，但访问慢。,,0,Code Walkthrough,,52aef575-2e10-4f6a-96ec-cb90d447a6c7,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,772:8-775:36,把形参 var 的访问点，改写成访问隐藏变量 .arguments 的第 i 个属性。这样以后所有读写参数其实都翻译成对 .arguments[i] 的读写，从而保证 arguments 对象和形参变量始终保持一致。,,0,Code Walkthrough,,0b17cbdb-c8cf-413c-933e-8a92b8edd162,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,174:4-174:13,this 指向 var,,0,Code Walkthrough,,ca6fceba-042a-40fe-af43-fba33935bb2a,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,181:4-181:11,在 locals_ 声明 arguments 特殊变量，,,0,Code Walkthrough,,25c7fc82-3f9a-499b-9fad-ea73a8b96e52,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,192:17-192:35,函数在它的 函数体内部要能引用自己的名字。,,0,Code Walkthrough,,c98c9372-cf7d-486a-bcca-74a59003f3db,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,208:12-208:24,函数 Scope 添加参数。locals_ 有这个 var，然后也加到 params_,,0,Code Walkthrough,,a15ffae5-2863-4859-ad1b-e08dcd80bfcc,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,237:22-237:34,temps_ 增加临时变量,,0,Code Walkthrough,,e5b81e8a-565c-4fda-8a4f-ed284fa404c9,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,39:35-39:35,Allocator 默认调用 free 和 malloc 。这里重写调用 Zone::New,,0,Code Walkthrough,,f08abe45-dc1f-4daf-be1e-6392bff52d7a,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/zone.h,,54:14-54:23,一次释放所有申请的内存,,0,Code Walkthrough,,39507e6c-786a-4d5b-a489-e5768c0414dc,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/zone.cc,,63:0-64:0,Segment 不光包含两个头信息字段，它剩下的“身体”就是用户请求的那一大快内存区。,,0,Code Walkthrough,,c8a93dce-1525-4c2d-9d77-3d739d0ba038,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,41:7-41:17,编译器为了更合理评估热度，调用时可能给权重,,0,Code Walkthrough,,b0edcb4c-5851-4f3e-b870-faa2521fb5d8,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,134:14-134:22,把源代码里写的“名字引用”节点 (VariableProxy) 替换成更精确、更低层的节点（Slot 或 Property）。,,0,Code Walkthrough,,74904752-bff5-4ebd-88bb-84865b860ccb,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,118:2-119:20,只有作用域管理器 (Scope) 和 VariableProxy 等“受信任的类” 才能 new Variable,friend 类才可以创建变量,0,Code Walkthrough,,8dbdae4d-f6ad-401c-95da-c805f613eb8f,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,129:11-129:20,表示 变量本身的值 被读/写的次数。,,0,Code Walkthrough,,9e5f97c0-7fd8-4e03-b66e-fa3b2c4ac569,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,130:11-130:20,表示 变量作为“对象/函数本身” 被当作目标使用的次数。,function f() {}\nvar g = f;\n\ng();         // 调用 → obj_uses_++\ng.x = 42;    // 当对象添加属性 → obj_uses_++,0,Code Walkthrough,,78439bb6-1d79-45fa-984f-d01333ca77a2,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/hashmap.h,,44:6-44:13,直接沿用最底层的 Malloced 内存管理，默认也就是 free 和 malloc。,,0,Code Walkthrough,,794a0f77-48aa-4915-89d7-fdcdead4b8ec,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,845:6-845:14,Property 表示对象属性访问,"FunctionLiteral(""""foo"""")\n│\n├── params_: [ """"x"""" ]\n│\n└── body:\n    ├── VariableDeclaration                 // var y = 1;\n    │      ├── VariableProxy(""""y"""")           // 声明的名字\n    │      └── Literal(1)                   // 初始化表达式\n    │\n    └── ReturnStatement                     // return ...\n           └── BinaryOperation(""""+"""")\n                 ├── BinaryOperation(""""+"""")\n                 │     ├── BinaryOperation(""""+"""")\n                 │     │      ├── VariableProxy(""""x"""")       // 使用参数 x\n                 │     │      └── VariableProxy(""""y"""")       // 使用局部 y\n                 │     │\n                 │     └── Property                        // obj[""""a""""]\n                 │            ├── VariableProxy(""""obj"""")     // 对象部分\n                 │            └── Literal(""""a"""")             // key 部分\n                 │\n                 └── Property                              // obj.b\n                        ├── VariableProxy(""""obj"""")\n                        └── Literal(""""b"""")",0,Code Walkthrough,,4895f2b5-3814-48f5-b718-6ed9d3fb522a,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,730:6-730:19,变量引用或者声明时的引用,"FunctionLiteral(""""foo"""")\n  ├── params_: [""""x""""]   // 形参\n  └── body:\n      ├── VariableDeclaration\n      │     ├── VariableProxy(""""y"""")   // 声明处的名字\n      │     └── Literal(1)           // 初始化\n      │\n      └── ReturnStatement\n            └── BinaryOperation(""""+"""")\n                  ├── BinaryOperation(""""+"""")\n                  │     ├── VariableProxy(""""x"""")   // return 里的 x\n                  │     └── VariableProxy(""""y"""")   // return 里的 y\n                  │\n                  └── VariableProxy(""""z"""")         // return 里的 z",0,Code Walkthrough,,09aeeafd-198b-47e7-be0f-eae4c71b29b9,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,770:11-770:20,UseCount 会在 BindTo 之后汇总到真正的 Variable 上，用于后续代码生成/优化的启发式判断,,0,Code Walkthrough,,a5c80489-8efc-4712-a804-449638d0048c,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,741:11-741:23,“this 怎么可能是 NULL”——按标准不应该；只有你通过空指针调用成员函数时才“可能”为 NULL，但那是未定义行为。这段代码是历史上的防御式写法，实务中常见但不推荐在新代码里照搬。,,0,Code Walkthrough,,c1a6cdce-9735-4edf-b85b-66e0755b8388,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,89:7-89:26,"能不能作为赋值或自增自减的“左边”（Left-Hand Side, LHS）。",,0,Code Walkthrough,,aef44fc4-a742-4264-9bd9-c4fc2059588b,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.h,,87:0-88:0,当使用 arguments 对象时，参数会被重写为 Property ,,0,Code Walkthrough,,e194db41-5ab7-467f-83ac-6cb671037fff,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/variables.cc,,105:35-105:43,Expression 转为 Property。底层本身就是 Property,,0,Code Walkthrough,,af631b9d-e032-4832-907a-79d4b7c82596,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/scopes.cc,,806:10-806:60,参数变量重写为 Slot,,0,Code Walkthrough,,4bb3909f-961d-4f65-bc36-c0b5a422cc85,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,171:6-171:24,因为 JS 语法允许 labeled block 被 break label; 跳出，它必须具备“break 目标”的特征。,,0,Code Walkthrough,,6915828e-f480-4056-ba40-e2953722e6d9,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,206:6-206:25, “breakStackHeight” 确实对应 操作数栈高度,在 V8 0.1.5 这种上古版本（2008 年刚开源那会儿），确实还是 stack‑based 的 JVM 风格模型。\n当时根本 还没有今天所说的 IR pipeline（Hydrogen/Lithium/Turbofan/Ignition bytecode），而是直接从 AST 一路吐汇编（Full-codegen）。,0,Code Walkthrough,,f50a90d2-1e88-4f4a-bb69-c863064ead73,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,248:2-248:15,声明里面是 VariableProxy，Scope 用到它,,0,Code Walkthrough,,ddccd39c-58b8-476c-80b2-39861bcc1b98,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,278:6-278:19,组合子的节点，实现 AST 的父子级的关系；另外它也继承基类实现逻辑共享,,0,Code Walkthrough,,5976a719-0833-43f0-9ede-2038099f9362,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,230:6-230:17,变量声明、函数声明、 常量声明,"特殊做法：函数表达式\n\nvar x = function hello() { return 1; };\n\nVarDeclaration\n ├─ Declaration\n │    ├─ proxy_: VariableProxy(""""x"""")   // 声明的名字是 x\n │    ├─ mode_: VAR\n │    └─ fun_: NULL                   // 注意！这里 fun_ 是 NULL\n └─ Initializer\n      └─ Assignment (=)\n           ├─ VariableProxy(""""x"""")\n           └─ FunctionLiteral(""""hello"""")   // FunctionExpression 节点\n                ├─ name: """"hello"""" (可选局部名)\n                └─ body: [ ReturnStatement Literal(1) ]\n",0,Code Walkthrough,,ec766282-9c83-4a2d-920b-bba34eada438,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,250:19-250:23,只有函数声明用到,"function foo(a, b) {\n  return a + b;\n}",0,Code Walkthrough,,4e8a9dda-d7a9-4633-bc3b-a214fb9fb40d,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,1116:6-1116:21,重要：语法层的函数定义表达式/声明,"语法层的函数定义表达式/声明\n\n\n\nfunction foo(a, b) {\n  return a + b;\n}\nvar bar = function(x) { return x * 2; };\n在 AST 上都会生成一个 FunctionLiteral 节点。\n\n包含信息：\n\nname_: 函数名字（匿名函数时可能是空字符串）。\nscope_: 函数作用域对象（捕获变量、参数、this 绑定）。\nbody_: 语句列表（函数体 AST）。\nmaterialized_literal_count_: 函数体里需要 materialize 的字面量数量。\nexpected_property_count_: 预期构造对象字面量的属性数量（优化 hint）。\nnum_parameters_: 参数个数。\nstart_position_, end_position_: 源码位置。\nis_expression_: 是“函数表达式”还是“函数声明”。\n👉 它就是“一个 JS 函数的源码 AST 节点”。",0,Code Walkthrough,,cec899f8-2be3-47c2-8b83-6e4e0a1ff532,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,424:6-424:16,switch 语句里每个 case/default 分支的 AST 节点,,0,Code Walkthrough,,b3c65617-5594-400b-8d99-96f8a82eb831,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,489:2-490:29,每种 Node/Statement 子类都有各自的 AsXXX() 转换或 type-tag。这样编译/代码生成时可以动态区分实际类型,Statement* s = if_stmt->then_statement_;\nif (s->AsBlock() != NULL) {\n   // then 分支是个块\n} else if (s->AsReturnStatement() != NULL) {\n   // then 分支是 return\n} else if (s->AsExpressionStatement() != NULL) {\n   // then 分支是表达式语句\n},0,Code Walkthrough,,98201a2c-e74d-489e-b25e-1f1c900652ae,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,496:6-496:20,临时收集和保存 Label* 列表，供带 label 的 break/continue 做静态绑定,举个伪例：源码 → LabelCollector 使用\nJavaScript\n\nfoo: { \n  bar: while (true) {\n    break foo;\n  }\n}\nparser 遇到 foo:，暂时没有真正的语句 target → 放进 LabelCollector。\n遇到 {…} → 创建 Block → 将 foo 绑定到 Block。\nBlock 继承自 BreakableStatement，可以接收 break label。\n遇到 bar: + while → 将 bar 绑定到 WhileLoop。\n遇到 break foo; → 通过 label 查找到 Block 的 break_target。 Done ✅,0,Code Walkthrough,,03789b3a-0d52-47fe-835c-a16e75ce76cf,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,578:6-578:23,js 语法：`debugger;`   // 在这里停下来（如果有调试器）,,0,Code Walkthrough,,ca614f79-a7d2-4e1c-9609-7777b4ad30a8,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,593:6-593:13,V8 AST 里最“基础”的 表达式节点 (Expression) 之一——它用来表示 字面量 (literal),"null\ntrue\nfalse\n42\n3.14\n""""hello""""\n\n/abc/      // RegExp literal\n[]         // Array literal\n{}         // Object literal\n\n\n示例 A：简单字面量\nJavaScript\n\nvar a = 42;\nAST（简化）：\n\n\n\nVarDeclaration\n └─ init: Literal(42)\n这里 Literal(42) 存放在 handle_ 里，指向 V8 Heap 中的 Smi 对象 42。",0,Code Walkthrough,,6118b183-4e1f-49f8-83da-9aab5fa78480,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,622:6-622:25,MaterializedLiteral ——它和前面简单的 Literal 不一样。这个类是 V8 早期 AST 用来表示那些 “需要在运行时真正分配对象”的字面量” 的基类,,0,Code Walkthrough,,9cf6e1c7-cd07-4dcf-a942-96dda51065a2,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,683:11-683:19,对象属性,,0,Code Walkthrough,,e8112d68-33aa-4243-a692-866d19e852b3,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,875:6-875:10,Call（普通调用）,,0,Code Walkthrough,,2795f7f8-c1ce-4d46-9739-b279a943e0c1,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,908:6-908:13,CallNew（构造调用）,,0,Code Walkthrough,,877316c6-06da-4714-834d-4a2e43cc4af3,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,921:6-921:17,源码里的“高级语法” → AST 初步节点 → Rewriter → CallRuntime → Runtime Helper,是的，CallRuntime 恰恰就是 V8 在 AST 转换 (Rewriter) 中引入的特殊节点。\n它不是语法，而是编译器“降级成 runtime helper 调用”的占位。\n常见被 rewrite 成 CallRuntime 的：\n对象字面量初始化\nRegExp 字面量\neval 特殊调用\n内置库方法的优化路径\n,0,Code Walkthrough,,00b09697-cbee-423e-bdca-276f94fcb2ee,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,941:6-941:20,对应 JS 源码里的 一元运算符表达式。比如：-x、!x、typeof x、delete obj.prop 这些，都会被建模成 UnaryOperation 节点。,,0,Code Walkthrough,,045b2f52-9a83-4689-b1a4-da5dee514eb4,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,1011:6-1011:20,"专门表示前缀/后缀自增自减：++x, x++。因为这类不仅是值，还涉及赋值，会比简单一元复杂。",,0,Code Walkthrough,,7b60775a-c882-490d-85d7-18f7a4a5ada3,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,1189:6-1189:18,只是引擎内部当你写到**“函数自身的引用”**（callee 或解析命名函数表达式时）会生成。,,0,Code Walkthrough,,6173e396-3129-426a-8ef0-62e88ac76b66,0
c6c642a9cc0ee8e3172030960a0cb840bd8aa364,/src/ast.h,,1173:6-1173:32,如果某个地方需要“在执行时生成或克隆一个 Function 对象”，AST 节点就放一个 FunctionBoilerplateLiteral 来指代那个“模板函数对象”。,看到源码 function foo() {} → 是 FunctionLiteral；\n看到对象/数组字面量里含函数属性 → AST 会存一个 FunctionBoilerplateLiteral，跑时 clone 模具。,0,Code Walkthrough,,e2b0df44-1eb3-4007-a6d7-e9589794351c,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/parser.cc,,526:6-526:23,Parser: 语法解析器类,,0,Code Walkthrough,,83fd3f35-d381-4785-bd4e-150fdf1283dc,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/parser.cc,,737:39-737:49,parser 的默认 top_scope_ 是 NULL,,0,Code Walkthrough,,905bfbed-acff-4e8c-82b8-2eeb8c90574c,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/compiler.cc,,210:19-210:23,is_global 是 true,,0,Code Walkthrough,,e97a390f-f4dc-44b5-8d0b-8ea0d5590148,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/parser.cc,,634:6-634:18,LexicalScope 就是个小 RAII 工具，保证进入/退出作用域时，parser 的 top_scope 状态成对切换，不会忘记恢复。,,0,Code Walkthrough,,ed04abfa-cead-4b62-b87d-b03b2fbc6157,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/parser.cc,,853:4-853:55,成功解析一条语句，添加到 processor，它负责收集,,0,Code Walkthrough,,9ed1711f-1a18-4a65-ab94-4897b6bd43f4,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/compiler.cc,,159:15-159:37,函数变为模板，克隆它生成新的函数对象。,,0,Code Walkthrough,,a170297a-f664-4151-ba61-ee0db345185c,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/parser.cc,,2889:12-2889:45,函数表达式关联到了它对应的 Scope，1个函数只有1个哦,,0,Code Walkthrough,,99628cc6-691f-488d-af1f-0acc1744d0c2,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/prettyprinter.cc,,984:4-984:26,打印的时候检查 rewrite ，所以打印优化过的,,0,Code Walkthrough,,cd7b30ea-9918-4707-b515-0a0a1175ee2f,0
98055bcea9b29411916f7a82413c2adf071f30c4,/src/codegen-ia32.cc,,3419:2-3419:34,也会检查 rewrite,,0,Code Walkthrough,,0e9b41cb-698f-4304-b1ae-c8cebdb8467d,0
083bcda64f5dcbdd486c27bc6a3e6dfd8213677f,/src/codegen-ia32.cc,,361:2-361:63,MakeCode 是静态函数,,0,Code Walkthrough,,420d09a9-14bf-4b19-8472-76f7f208f545,0

083bcda64f5dcbdd486c27bc6a3e6dfd8213677f,/src/assembler-ia32.cc,,384:2-384:16,生成的命令都是通过 pc 来写入的,,0,Code Walkthrough,,aac40600-c3d7-467a-aaf5-5f11776154ee,0

083bcda64f5dcbdd486c27bc6a3e6dfd8213677f,/src/codegen-ia32.cc,,409:6-409:51,初始化 masm ,,0,Code Walkthrough,,cf8693c5-72d9-4fc1-91b3-cc0e9fbb61c7,0

